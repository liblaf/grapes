{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Explore the docs \u00bb</p> <p> </p> <p>Changelog \u00b7 Report Bug \u00b7 Request Feature</p> <p></p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>\ud83c\udfa8 Rich Logging: Beautiful, structured logging with loguru integration, multiple output formats (rich console, JSONL, file), and customizable profiles for different environments;</li> <li>\u23f1\ufe0f Precise Timing: Easy-to-use timing decorators and context managers with detailed statistics (mean, median, stdev) and automatic logging integration;</li> <li>\ud83d\udce6 Multi-Format Serialization: Unified interface for JSON, TOML, and YAML serialization with Pydantic model support and customizable encoding/decoding hooks;</li> <li>\ud83d\udc65 Human-Readable Formats: Intelligent conversion of numbers, durations, and throughput into human-readable strings with appropriate units and precision;</li> <li>\ud83d\udd04 Progress Tracking: Integrated progress bars with rich visualization, timing integration, and parallel processing support through joblib;</li> <li>\u2699\ufe0f Smart Configuration: Environment-aware configuration system using Pydantic with automatic environment variable parsing and type-safe settings.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install <code>liblaf-grapes</code>, run the following command:</p> <pre><code>uv add liblaf-grapes\n</code></pre>"},{"location":"#local-development","title":"\u2328\ufe0f Local Development","text":"<p>You can use Github Codespaces for online development:</p> <p></p> <p>Or clone it for local development:</p> <pre><code>gh repo clone liblaf/grapes\ncd grapes\nmise run install\n</code></pre>"},{"location":"#contributing","title":"\ud83e\udd1d Contributing","text":"<p>Contributions of all types are more than welcome, if you are interested in contributing code, feel free to check out our GitHub Issues to get stuck in to show us what you\u2019re made of.</p> <p></p> <p></p>"},{"location":"#more-projects","title":"\ud83d\udd17 More Projects","text":"<ul> <li>\ud83c\udf47 Grapes - Supercharge your Python with rich logging, precise timing, and seamless serialization.</li> <li>\ud83c\udf49 Melon - A comprehensive Python library for 3D mesh processing with advanced I/O capabilities, proximity analysis, and integration with external mesh processing tools.</li> <li>\ud83c\udf4a Tangerine - Squeeze dynamic content into your files with Tangerine\u2019s template magic.</li> <li>\ud83c\udf4b\u200d\ud83d\udfe9 Lime - AI-powered Git commit assistant and repository documentation generator</li> <li>\ud83c\udf4e Apple - A JAX and Warp library for differentiable physics simulation, featuring elastic energy models and finite element methods.</li> <li>\ud83c\udf52 Cherries - Sweet experiment tracking with Comet, DVC, and Git integration.</li> </ul>"},{"location":"#license","title":"\ud83d\udcdd License","text":"<p>Copyright \u00a9 2025 liblaf.  This project is MIT licensed.</p>"},{"location":"reference/liblaf/grapes/","title":"grapes","text":""},{"location":"reference/liblaf/grapes/#liblaf.grapes","title":"liblaf.grapes","text":"<p>Modules:</p> <ul> <li> <code>conf</code>           \u2013            </li> <li> <code>deps</code>           \u2013            <p>This module provides utility functions for handling optional imports and checking module availability.</p> </li> <li> <code>env</code>           \u2013            <p>Initialize and return an environment configuration.</p> </li> <li> <code>error</code>           \u2013            </li> <li> <code>functools</code>           \u2013            </li> <li> <code>git</code>           \u2013            </li> <li> <code>itertools</code>           \u2013            </li> <li> <code>logging</code>           \u2013            </li> <li> <code>pretty</code>           \u2013            </li> <li> <code>sentinel</code>           \u2013            </li> <li> <code>serde</code>           \u2013            <p>This module provides functions for serialization and deserialization of various data formats, including JSON, TOML, YAML, and Pydantic models. It also includes registries for mapping file extensions to their respective serialization and deserialization functions.</p> </li> <li> <code>timing</code>           \u2013            </li> <li> <code>tqdm</code>           \u2013            <p>This module provides progress tracking utilities, including a custom rate column for progress bars and a function to track the progress of iterating over sequences.</p> </li> <li> <code>typing</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>ClassInfo</code>           \u2013            </li> <li> <code>ClockName</code>           \u2013            </li> <li> <code>DecHook</code>           \u2013            </li> <li> <code>EncHook</code>           \u2013            </li> <li> <code>PathLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>BaseConfig</code>           \u2013            </li> <li> <code>BaseModel</code>           \u2013            </li> <li> <code>BaseTimer</code>           \u2013            </li> <li> <code>Config</code>           \u2013            </li> <li> <code>DispatchLookupError</code>           \u2013            </li> <li> <code>MatchError</code>           \u2013            </li> <li> <code>MemorizedFunc</code>           \u2013            </li> <li> <code>Progress</code>           \u2013            </li> <li> <code>PydanticModelDumpOptions</code>           \u2013            </li> <li> <code>PydanticModelValidateOptions</code>           \u2013            </li> <li> <code>RateColumn</code>           \u2013            </li> <li> <code>Serde</code>           \u2013            </li> <li> <code>Timer</code>           \u2013            </li> <li> <code>Timings</code>           \u2013            </li> <li> <code>TodoError</code>           \u2013            </li> <li> <code>UnreachableError</code>           \u2013            </li> <li> <code>WadlerLindigOptions</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>array_kind</code>             \u2013              </li> <li> <code>as_iterable</code>             \u2013              <p>.</p> </li> <li> <code>as_sequence</code>             \u2013              <p>.</p> </li> <li> <code>auto_repr</code>             \u2013              </li> <li> <code>cache</code>             \u2013              </li> <li> <code>choose_duration_format</code>             \u2013              </li> <li> <code>clock</code>             \u2013              </li> <li> <code>clone_param_spec</code>             \u2013              </li> <li> <code>clone_signature</code>             \u2013              </li> <li> <code>dec_hook</code>             \u2013              </li> <li> <code>deep_merge</code>             \u2013              </li> <li> <code>enc_hook</code>             \u2013              </li> <li> <code>first_not_none</code>             \u2013              <p>Returns the first <code>not None</code> value in the <code>args</code>.</p> </li> <li> <code>get_console</code>             \u2013              </li> <li> <code>get_timer</code>             \u2013              </li> <li> <code>has_ansi</code>             \u2013              </li> <li> <code>has_module</code>             \u2013              </li> <li> <code>len_or_none</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>nop</code>             \u2013              </li> <li> <code>optional_imports</code>             \u2013              </li> <li> <code>parallel</code>             \u2013              </li> <li> <code>pdoc_attrs</code>             \u2013              <p>.</p> </li> <li> <code>pdoc_custom</code>             \u2013              </li> <li> <code>pformat</code>             \u2013              </li> <li> <code>pretty_call</code>             \u2013              </li> <li> <code>pretty_duration</code>             \u2013              <p>.</p> </li> <li> <code>pretty_func</code>             \u2013              </li> <li> <code>pretty_throughput</code>             \u2013              </li> <li> <code>rich_location</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> <li> <code>timer</code>             \u2013              </li> <li> <code>todo</code>             \u2013              </li> <li> <code>track</code>             \u2013              </li> <li> <code>try_import</code>             \u2013              </li> <li> <code>unreachable</code>             \u2013              </li> <li> <code>wrapt_getattr</code>             \u2013              </li> <li> <code>wrapt_setattr</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>MISSING</code>           \u2013            </li> <li> <code>NOP</code>           \u2013            </li> <li> <code>__version__</code>               (<code>str</code>)           \u2013            </li> <li> <code>__version_tuple__</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> <li> <code>config</code>           \u2013            </li> <li> <code>json</code>           \u2013            </li> <li> <code>toml</code>           \u2013            </li> <li> <code>version</code>               (<code>str</code>)           \u2013            </li> <li> <code>version_tuple</code>               (<code>tuple[int | str, ...]</code>)           \u2013            </li> <li> <code>yaml</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MISSING","title":"MISSING  <code>module-attribute</code>","text":"<pre><code>MISSING = Sentinel('MISSING')\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.NOP","title":"NOP  <code>module-attribute</code>","text":"<pre><code>NOP = Sentinel('NOP')\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str = '6.1.2.dev5+g288e3ef40'\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.__version_tuple__","title":"__version_tuple__  <code>module-attribute</code>","text":"<pre><code>__version_tuple__: tuple[int | str, ...] = (\n    6,\n    1,\n    2,\n    \"dev5\",\n    \"g288e3ef40\",\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.config","title":"config  <code>module-attribute</code>","text":"<pre><code>config = Config()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.json","title":"json  <code>module-attribute</code>","text":"<pre><code>json = Serde(decoder=decode, encoder=encode)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.toml","title":"toml  <code>module-attribute</code>","text":"<pre><code>toml = Serde(decoder=decode, encoder=encode)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.version","title":"version  <code>module-attribute</code>","text":"<pre><code>version: str = '6.1.2.dev5+g288e3ef40'\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.version_tuple","title":"version_tuple  <code>module-attribute</code>","text":"<pre><code>version_tuple: tuple[int | str, ...] = (\n    6,\n    1,\n    2,\n    \"dev5\",\n    \"g288e3ef40\",\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.yaml","title":"yaml  <code>module-attribute</code>","text":"<pre><code>yaml = Serde(decoder=decode, encoder=encode)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.ClassInfo","title":"ClassInfo","text":"<pre><code>ClassInfo = type | UnionType | tuple[ClassInfo, ...]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.ClockName","title":"ClockName","text":"<pre><code>ClockName = Literal[\n    \"monotonic\",\n    \"perf\",\n    \"process\",\n    \"thread\",\n    \"time\",\n    \"children-system\",\n    \"children-user\",\n    \"elapsed\",\n    \"system\",\n    \"user\",\n]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.DecHook","title":"DecHook","text":"<pre><code>DecHook = Callable[[type, Any], Any]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.EncHook","title":"EncHook","text":"<pre><code>EncHook = Callable[[Any], Any]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PathLike","title":"PathLike","text":"<pre><code>PathLike = str | PathLike[str]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseConfig","title":"BaseConfig","text":"<p>               Bases: <code>OverridesMixin</code>, <code>BaseSettings</code></p> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseConfig.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseConfig.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseModel","title":"BaseModel  <code>pydantic-model</code>","text":"<p>               Bases: <code>OverridesMixin</code>, <code>BaseModel</code></p> Show JSON schema: <pre><code>{\n  \"properties\": {},\n  \"title\": \"BaseModel\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Config:</p> <ul> <li><code>validate_assignment</code>: <code>True</code></li> <li><code>arbitrary_types_allowed</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseModel.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer","title":"BaseTimer","text":"<p>               Bases: <code>Timings</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clocks</code>               (<code>Sequence[ClockName]</code>, default:                   <code>('perf',)</code> )           \u2013            </li> <li> <code>cb_start</code>               (<code>Callback | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>cb_stop</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_record at 0x7f691c654680&gt;</code> )           \u2013            </li> <li> <code>cb_finish</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_summary at 0x7f691c655300&gt;</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>timings</code>               (<code>dict[ClockName, list[float]]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>elapsed</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>pretty_record</code>             \u2013              </li> <li> <code>pretty_summary</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> <li> <code>stop</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.cb_finish","title":"cb_finish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_finish: Callback | None = log_summary\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.cb_start","title":"cb_start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_start: Callback | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.cb_stop","title":"cb_stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_stop: Callback | None = log_record\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.clocks","title":"clocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clocks: Sequence[ClockName] = field(default=DEFAULT_CLOCKS)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.default_clock","title":"default_clock  <code>property</code>","text":"<pre><code>default_clock: ClockName\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.timings","title":"timings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timings: dict[ClockName, list[float]] = field(\n    factory=lambda: defaultdict(list), init=False\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.timings[self.default_clock])\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def clear(self) -&gt; None:\n    self.timings.clear()\n    self._start_time.clear()\n    self._stop_time.clear()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.elapsed","title":"elapsed","text":"<pre><code>elapsed(clock_name: ClockName | None = None) -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def elapsed(self, clock_name: ClockName | None = None) -&gt; float:\n    clock_name = clock_name or self.default_clock\n    stop_time: float\n    if clock_name in self._stop_time:\n        stop_time = self._stop_time[clock_name]\n    else:\n        stop_time = clock(clock_name)\n    return stop_time - self._start_time[clock_name]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.finish","title":"finish","text":"<pre><code>finish() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def finish(self) -&gt; None:\n    __tracebackhide__ = True\n    if self.cb_finish is not None and self.cb_finish is not NOP:\n        self.cb_finish(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.log_record","title":"log_record","text":"<pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_record(\n    self,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None:\n    __tracebackhide__ = True\n    if threshold_sec is not None and self.elapsed() &lt; threshold_sec:\n        return\n    logger.log(level, self.pretty_record(index=index))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_summary(\n    self,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None:\n    __tracebackhide__ = True\n    logger.log(level, self.pretty_summary(stats=stats))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.pretty_record","title":"pretty_record","text":"<pre><code>pretty_record(index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_record(self, index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str:\n    name: str = self.name or \"Timer\"\n    items: list[str] = [\n        f\"{clock_name}: {pretty.pretty_duration(self.timings[clock_name][index])}\"\n        for clock_name in self.clocks\n    ]\n    items_str: str = \", \".join(items)\n    return f\"{name} &gt; {items_str}\"\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.pretty_summary","title":"pretty_summary","text":"<pre><code>pretty_summary(\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_summary(\n    self, stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS\n) -&gt; str:\n    name: str = self.name or \"Timer\"\n    header: str = f\"{name} (count: {len(self)})\"\n    if len(self) == 0:\n        return header\n    lines: list[str] = []\n    for clock_name in self.clocks:\n        stats_str: list[str] = []\n        for stat in stats:\n            stat_name: str\n            value: str\n            stat_name, value = pretty_statistic(self.timings[clock_name], stat)\n            stats_str.append(f\"{stat_name}: {value}\")\n        line: str = f\"{clock_name} &gt; {', '.join(stats_str)}\"\n        lines.append(line)\n    if len(self.clocks) == 1:\n        return f\"{header} {lines[0]}\"\n    return f\"{header}\\n\" + \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def start(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        self._start_time[clock_name] = clock(clock_name)\n    self._stop_time.clear()\n    if self.cb_start is not None and self.cb_start is not NOP:\n        self.cb_start(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.BaseTimer.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def stop(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        stop_time: float = clock(clock_name)\n        self._stop_time[clock_name] = stop_time\n        self.timings[clock_name].append(stop_time - self._start_time[clock_name])\n    if self.cb_stop is not None and self.cb_stop is not NOP:\n        self.cb_stop(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config","title":"Config","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Parameters:</p> <ul> <li> <code>joblib</code>               (<code>ConfigJoblib</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>logging</code>               (<code>ConfigLogging</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>pretty</code>               (<code>ConfigPretty</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>.</p> <p>References:     1. wadler_lindig.pformat</p> </li> <li> <code>traceback</code>               (<code>ConfigTraceback</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>joblib</code>               (<code>ConfigJoblib</code>)           \u2013            </li> <li> <code>logging</code>               (<code>ConfigLogging</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>pretty</code>               (<code>ConfigPretty</code>)           \u2013            </li> <li> <code>traceback</code>               (<code>ConfigTraceback</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config.joblib","title":"joblib  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>joblib: ConfigJoblib = Field(default_factory=ConfigJoblib)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: ConfigLogging = Field(\n    default_factory=ConfigLogging\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config.pretty","title":"pretty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pretty: ConfigPretty = Field(default_factory=ConfigPretty)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config.traceback","title":"traceback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traceback: ConfigTraceback = Field(\n    default_factory=ConfigTraceback\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Config.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.DispatchLookupError","title":"DispatchLookupError","text":"<pre><code>DispatchLookupError(\n    func: Callable,\n    args: Sequence = (),\n    kwargs: Mapping = {},\n)\n</code></pre> <p>               Bases: <code>LookupError</code></p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            </li> <li> <code>params</code>               (<code>Params</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            </li> <li> <code>params</code>               (<code>Params</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/error/_dispatch.py</code> <pre><code>def __init__(\n    self, func: Callable, args: Sequence = (), kwargs: Mapping = {}\n) -&gt; None:\n    params = Params(args=args, kwargs=kwargs)\n    self.__attrs_init__(func=func, params=params)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.DispatchLookupError.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func: Callable\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.DispatchLookupError.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: Params\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.DispatchLookupError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_dispatch.py</code> <pre><code>def __str__(self) -&gt; str:\n    from liblaf.grapes import pretty\n\n    pretty_call: str = pretty.pretty_call(\n        self.func, self.params.args, self.params.kwargs\n    )\n    return f\"`{pretty_call}` could not be resolved.\"\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MatchError","title":"MatchError","text":"<p>               Bases: <code>ValueError</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Any</code>)           \u2013            </li> <li> <code>typ</code>               (<code>str | type</code>, default:                   <code>'match'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>typ</code>               (<code>str | type</code>)           \u2013            </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MatchError.typ","title":"typ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>typ: str | type = 'match'\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MatchError.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MatchError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_match.py</code> <pre><code>def __str__(self) -&gt; str:\n    cls: str = self.typ if isinstance(self.typ, str) else self.typ.__qualname__\n    return f\"{self.value!r} is not a valid {cls}.\"\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MemorizedFunc","title":"MemorizedFunc","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.MemorizedFunc.__call__","title":"__call__","text":"<pre><code>__call__(*args: P.args, **kwargs: P.kwargs) -&gt; T\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_cache.py</code> <pre><code>def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Progress","title":"Progress","text":"<pre><code>Progress(\n    *columns: str | ProgressColumn,\n    console: Console | None = None,\n    timer: Timer | Literal[False] | None = None,\n)\n</code></pre> <p>               Bases: <code>Progress</code></p> <p>Methods:</p> <ul> <li> <code>get_default_columns</code>             \u2013              </li> <li> <code>track</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>timer</code>               (<code>Timer | Literal[False]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>def __init__(\n    self,\n    *columns: str | ProgressColumn,\n    console: Console | None = None,\n    timer: timing.Timer | Literal[False] | None = None,\n) -&gt; None:\n    if console is None:\n        console = pretty.get_console(stderr=True)\n    super().__init__(*columns, console=console)\n    if timer is None:\n        timer = timing.timer()\n    self.timer = timer\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Progress.timer","title":"timer  <code>instance-attribute</code>","text":"<pre><code>timer: Timer | Literal[False] = timer\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Progress.get_default_columns","title":"get_default_columns  <code>classmethod</code>","text":"<pre><code>get_default_columns() -&gt; tuple[str | ProgressColumn, ...]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>@override\n@classmethod\ndef get_default_columns(cls) -&gt; tuple[str | ProgressColumn, ...]:  # pyright: ignore[reportIncompatibleMethodOverride]\n    return (\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        MofNCompleteColumn(),\n        \"[\",\n        TimeElapsedColumn(),\n        \"&lt;\",\n        TimeRemainingColumn(),\n        \",\",\n        RateColumn(),\n        \"]\",\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Progress.track","title":"track","text":"<pre><code>track(\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    task_id: TaskID | None = None,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    timer: Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>@override\ndef track[T](\n    self,\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    task_id: TaskID | None = None,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    timer: timing.Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]:\n    __tracebackhide__ = True\n    if total is None:\n        total = _it.len_or_none(sequence)\n    if timer := (timer or self.timer):\n        sequence = timer(sequence)\n        timing.get_timer(sequence).name = description\n    yield from super().track(\n        sequence,\n        total=total,\n        completed=completed,\n        task_id=task_id,\n        description=description,\n        update_period=update_period,\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions","title":"PydanticModelDumpOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>Literal['json', 'python']</code>)           \u2013            </li> <li> <code>include</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>exclude</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            </li> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>exclude_unset</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_none</code>               (<code>bool</code>)           \u2013            </li> <li> <code>round_trip</code>               (<code>bool</code>)           \u2013            </li> <li> <code>warnings</code>               (<code>bool | Literal['none', 'warn', 'error']</code>)           \u2013            </li> <li> <code>fallback</code>               (<code>Callable[list, Any] | None</code>)           \u2013            </li> <li> <code>serialize_as_any</code>               (<code>bool</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            </li> <li> <code>exclude</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>exclude_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_none</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_unset</code>               (<code>bool</code>)           \u2013            </li> <li> <code>fallback</code>               (<code>Callable[[Any], Any] | None</code>)           \u2013            </li> <li> <code>include</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>mode</code>               (<code>Literal['json', 'python']</code>)           \u2013            </li> <li> <code>round_trip</code>               (<code>bool</code>)           \u2013            </li> <li> <code>serialize_as_any</code>               (<code>bool</code>)           \u2013            </li> <li> <code>warnings</code>               (<code>bool | Literal['none', 'warn', 'error']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.by_alias","title":"by_alias  <code>instance-attribute</code>","text":"<pre><code>by_alias: bool | None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Any | None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.exclude","title":"exclude  <code>instance-attribute</code>","text":"<pre><code>exclude: IncEx | None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.exclude_defaults","title":"exclude_defaults  <code>instance-attribute</code>","text":"<pre><code>exclude_defaults: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.exclude_none","title":"exclude_none  <code>instance-attribute</code>","text":"<pre><code>exclude_none: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.exclude_unset","title":"exclude_unset  <code>instance-attribute</code>","text":"<pre><code>exclude_unset: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.fallback","title":"fallback  <code>instance-attribute</code>","text":"<pre><code>fallback: Callable[[Any], Any] | None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.include","title":"include  <code>instance-attribute</code>","text":"<pre><code>include: IncEx | None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.mode","title":"mode  <code>instance-attribute</code>","text":"<pre><code>mode: Literal['json', 'python']\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.round_trip","title":"round_trip  <code>instance-attribute</code>","text":"<pre><code>round_trip: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.serialize_as_any","title":"serialize_as_any  <code>instance-attribute</code>","text":"<pre><code>serialize_as_any: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelDumpOptions.warnings","title":"warnings  <code>instance-attribute</code>","text":"<pre><code>warnings: bool | Literal['none', 'warn', 'error']\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelValidateOptions","title":"PydanticModelValidateOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool | None</code>)           \u2013            <p>Whether to enforce types strictly.</p> </li> <li> <code>from_attributes</code>               (<code>bool | None</code>)           \u2013            <p>Whether to extract data from object attributes.</p> </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            <p>Additional context to pass to the validator.</p> </li> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s alias when validating against the provided input data.</p> </li> <li> <code>by_name</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s name when validating against the provided input data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s alias when validating against the provided input data.</p> </li> <li> <code>by_name</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s name when validating against the provided input data.</p> </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            <p>Additional context to pass to the validator.</p> </li> <li> <code>from_attributes</code>               (<code>bool | None</code>)           \u2013            <p>Whether to extract data from object attributes.</p> </li> <li> <code>strict</code>               (<code>bool | None</code>)           \u2013            <p>Whether to enforce types strictly.</p> </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelValidateOptions.by_alias","title":"by_alias  <code>instance-attribute</code>","text":"<pre><code>by_alias: bool | None\n</code></pre> <p>Whether to use the field\u2019s alias when validating against the provided input data.</p>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelValidateOptions.by_name","title":"by_name  <code>instance-attribute</code>","text":"<pre><code>by_name: bool | None\n</code></pre> <p>Whether to use the field\u2019s name when validating against the provided input data.</p>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelValidateOptions.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Any | None\n</code></pre> <p>Additional context to pass to the validator.</p>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelValidateOptions.from_attributes","title":"from_attributes  <code>instance-attribute</code>","text":"<pre><code>from_attributes: bool | None\n</code></pre> <p>Whether to extract data from object attributes.</p>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.PydanticModelValidateOptions.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: bool | None\n</code></pre> <p>Whether to enforce types strictly.</p>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.RateColumn","title":"RateColumn","text":"<pre><code>RateColumn(\n    unit: str = \"it\", table_column: Column | None = None\n)\n</code></pre> <p>               Bases: <code>ProgressColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>unit</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>def __init__(self, unit: str = \"it\", table_column: Column | None = None) -&gt; None:\n    super().__init__(table_column)\n    self.unit = unit\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.RateColumn.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: str = unit\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.RateColumn.render","title":"render","text":"<pre><code>render(task: Task) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>def render(self, task: Task) -&gt; RenderableType:\n    if not task.speed:\n        return Text(f\"?{self.unit}/s\", style=\"progress.data.speed\")\n    throughput: str = pretty.pretty_throughput(task.speed, self.unit)\n    return Text(throughput, style=\"progress.data.speed\")\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde","title":"Serde","text":"<p>Parameters:</p> <ul> <li> <code>decoder</code>               (<code>Decoder</code>)           \u2013            </li> <li> <code>encoder</code>               (<code>Encoder</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>decode</code>             \u2013              </li> <li> <code>encode</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>decoder</code>               (<code>Decoder</code>)           \u2013            </li> <li> <code>encoder</code>               (<code>Encoder</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde.decoder","title":"decoder  <code>instance-attribute</code>","text":"<pre><code>decoder: Decoder\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde.encoder","title":"encoder  <code>instance-attribute</code>","text":"<pre><code>encoder: Encoder\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde.decode","title":"decode","text":"<pre><code>decode(\n    buf: Buffer | str,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n) -&gt; Any\n</code></pre><pre><code>decode(\n    buf: Buffer | str,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: type[T],\n) -&gt; T\n</code></pre><pre><code>decode(\n    buf: Buffer | str,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: Any,\n) -&gt; Any\n</code></pre> <pre><code>decode(buf: Buffer | str, /, **kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def decode(self, buf: Buffer | str, /, **kwargs) -&gt; Any:\n    if \"dec_hook\" not in kwargs:\n        kwargs[\"dec_hook\"] = functools.partial(\n            dec_hook, pydantic_options=kwargs.pop(\"pydantic\", None)\n        )\n    return self.decoder(buf, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde.encode","title":"encode","text":"<pre><code>encode(\n    obj: Any,\n    /,\n    *,\n    enc_hook: EncHook | None = ...,\n    order: Literal[\"deterministic\", \"sorted\"] | None = None,\n    pydantic: PydanticModelDumpOptions | None = None,\n) -&gt; bytes\n</code></pre> <pre><code>encode(obj: Any, /, **kwargs) -&gt; bytes\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def encode(self, obj: Any, /, **kwargs) -&gt; bytes:\n    if \"enc_hook\" not in kwargs:\n        kwargs[\"enc_hook\"] = functools.partial(\n            enc_hook, pydantic_options=kwargs.pop(\"pydantic\", None)\n        )\n    return self.encoder(obj, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde.load","title":"load","text":"<pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n) -&gt; Any\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: type[T],\n) -&gt; T\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: Any,\n) -&gt; Any\n</code></pre> <pre><code>load(path: PathLike, /, **kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def load(self, path: PathLike, /, **kwargs) -&gt; Any:\n    path = Path(path)\n    return self.decode(path.read_bytes(), **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Serde.save","title":"save","text":"<pre><code>save(\n    path: PathLike,\n    obj: Any,\n    /,\n    *,\n    enc_hook: EncHook | None = ...,\n    order: Literal[\"deterministic\", \"sorted\"] | None = None,\n    pydantic: PydanticModelDumpOptions | None = None,\n) -&gt; None\n</code></pre> <pre><code>save(path: PathLike, obj: Any, /, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def save(self, path: PathLike, obj: Any, /, **kwargs) -&gt; None:\n    path = Path(path)\n    path.write_bytes(self.encode(obj, **kwargs))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer","title":"Timer","text":"<p>               Bases: <code>BaseTimer</code>, <code>AbstractContextManager</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clocks</code>               (<code>Sequence[ClockName]</code>, default:                   <code>('perf',)</code> )           \u2013            </li> <li> <code>cb_start</code>               (<code>Callback | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>cb_stop</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_record at 0x7f691c654680&gt;</code> )           \u2013            </li> <li> <code>cb_finish</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_summary at 0x7f691c655300&gt;</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>timings</code>               (<code>dict[ClockName, list[float]]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              </li> <li> <code>__call__</code>             \u2013              </li> <li> <code>__enter__</code>             \u2013              </li> <li> <code>__exit__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>elapsed</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>pretty_record</code>             \u2013              </li> <li> <code>pretty_summary</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> <li> <code>stop</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.cb_finish","title":"cb_finish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_finish: Callback | None = log_summary\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.cb_start","title":"cb_start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_start: Callback | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.cb_stop","title":"cb_stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_stop: Callback | None = log_record\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.clocks","title":"clocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clocks: Sequence[ClockName] = field(default=DEFAULT_CLOCKS)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.default_clock","title":"default_clock  <code>property</code>","text":"<pre><code>default_clock: ClockName\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.timings","title":"timings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timings: dict[ClockName, list[float]] = field(\n    factory=lambda: defaultdict(list), init=False\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.__call__","title":"__call__","text":"<pre><code>__call__(func: C) -&gt; C\n</code></pre><pre><code>__call__(iterable: I) -&gt; I\n</code></pre> <pre><code>__call__(func_or_iterable: Callable | Iterable) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timer.py</code> <pre><code>def __call__(self, func_or_iterable: Callable | Iterable, /) -&gt; Any:\n    if callable(func_or_iterable):\n        return timed_callable(func_or_iterable, self)\n    return TimedIterable(func_or_iterable, self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timer.py</code> <pre><code>@override  # contextlib.AbstractContextManager\ndef __enter__(self) -&gt; Self:\n    __tracebackhide__ = True\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timer.py</code> <pre><code>@override  # contextlib.AbstractContextManager\ndef __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: types.TracebackType | None,\n    /,\n) -&gt; None:\n    __tracebackhide__ = True\n    self.stop()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.timings[self.default_clock])\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def clear(self) -&gt; None:\n    self.timings.clear()\n    self._start_time.clear()\n    self._stop_time.clear()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.elapsed","title":"elapsed","text":"<pre><code>elapsed(clock_name: ClockName | None = None) -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def elapsed(self, clock_name: ClockName | None = None) -&gt; float:\n    clock_name = clock_name or self.default_clock\n    stop_time: float\n    if clock_name in self._stop_time:\n        stop_time = self._stop_time[clock_name]\n    else:\n        stop_time = clock(clock_name)\n    return stop_time - self._start_time[clock_name]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.finish","title":"finish","text":"<pre><code>finish() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def finish(self) -&gt; None:\n    __tracebackhide__ = True\n    if self.cb_finish is not None and self.cb_finish is not NOP:\n        self.cb_finish(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.log_record","title":"log_record","text":"<pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_record(\n    self,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None:\n    __tracebackhide__ = True\n    if threshold_sec is not None and self.elapsed() &lt; threshold_sec:\n        return\n    logger.log(level, self.pretty_record(index=index))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_summary(\n    self,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None:\n    __tracebackhide__ = True\n    logger.log(level, self.pretty_summary(stats=stats))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.pretty_record","title":"pretty_record","text":"<pre><code>pretty_record(index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_record(self, index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str:\n    name: str = self.name or \"Timer\"\n    items: list[str] = [\n        f\"{clock_name}: {pretty.pretty_duration(self.timings[clock_name][index])}\"\n        for clock_name in self.clocks\n    ]\n    items_str: str = \", \".join(items)\n    return f\"{name} &gt; {items_str}\"\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.pretty_summary","title":"pretty_summary","text":"<pre><code>pretty_summary(\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_summary(\n    self, stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS\n) -&gt; str:\n    name: str = self.name or \"Timer\"\n    header: str = f\"{name} (count: {len(self)})\"\n    if len(self) == 0:\n        return header\n    lines: list[str] = []\n    for clock_name in self.clocks:\n        stats_str: list[str] = []\n        for stat in stats:\n            stat_name: str\n            value: str\n            stat_name, value = pretty_statistic(self.timings[clock_name], stat)\n            stats_str.append(f\"{stat_name}: {value}\")\n        line: str = f\"{clock_name} &gt; {', '.join(stats_str)}\"\n        lines.append(line)\n    if len(self.clocks) == 1:\n        return f\"{header} {lines[0]}\"\n    return f\"{header}\\n\" + \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def start(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        self._start_time[clock_name] = clock(clock_name)\n    self._stop_time.clear()\n    if self.cb_start is not None and self.cb_start is not NOP:\n        self.cb_start(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timer.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def stop(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        stop_time: float = clock(clock_name)\n        self._stop_time[clock_name] = stop_time\n        self.timings[clock_name].append(stop_time - self._start_time[clock_name])\n    if self.cb_stop is not None and self.cb_stop is not NOP:\n        self.cb_stop(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings","title":"Timings","text":"<p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clocks</code>               (<code>Sequence[ClockName]</code>, default:                   <code>('perf',)</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>timings</code>               (<code>dict[ClockName, list[float]]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>elapsed</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>pretty_record</code>             \u2013              </li> <li> <code>pretty_summary</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.clocks","title":"clocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clocks: Sequence[ClockName] = field(default=DEFAULT_CLOCKS)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.default_clock","title":"default_clock  <code>property</code>","text":"<pre><code>default_clock: ClockName\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.timings","title":"timings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timings: dict[ClockName, list[float]] = field(\n    factory=lambda: defaultdict(list), init=False\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.timings[self.default_clock])\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def clear(self) -&gt; None:\n    self.timings.clear()\n    self._start_time.clear()\n    self._stop_time.clear()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.elapsed","title":"elapsed","text":"<pre><code>elapsed(clock_name: ClockName | None = None) -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def elapsed(self, clock_name: ClockName | None = None) -&gt; float:\n    clock_name = clock_name or self.default_clock\n    stop_time: float\n    if clock_name in self._stop_time:\n        stop_time = self._stop_time[clock_name]\n    else:\n        stop_time = clock(clock_name)\n    return stop_time - self._start_time[clock_name]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.log_record","title":"log_record","text":"<pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_record(\n    self,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None:\n    __tracebackhide__ = True\n    if threshold_sec is not None and self.elapsed() &lt; threshold_sec:\n        return\n    logger.log(level, self.pretty_record(index=index))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_summary(\n    self,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None:\n    __tracebackhide__ = True\n    logger.log(level, self.pretty_summary(stats=stats))\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.pretty_record","title":"pretty_record","text":"<pre><code>pretty_record(index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_record(self, index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str:\n    name: str = self.name or \"Timer\"\n    items: list[str] = [\n        f\"{clock_name}: {pretty.pretty_duration(self.timings[clock_name][index])}\"\n        for clock_name in self.clocks\n    ]\n    items_str: str = \", \".join(items)\n    return f\"{name} &gt; {items_str}\"\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.Timings.pretty_summary","title":"pretty_summary","text":"<pre><code>pretty_summary(\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_summary(\n    self, stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS\n) -&gt; str:\n    name: str = self.name or \"Timer\"\n    header: str = f\"{name} (count: {len(self)})\"\n    if len(self) == 0:\n        return header\n    lines: list[str] = []\n    for clock_name in self.clocks:\n        stats_str: list[str] = []\n        for stat in stats:\n            stat_name: str\n            value: str\n            stat_name, value = pretty_statistic(self.timings[clock_name], stat)\n            stats_str.append(f\"{stat_name}: {value}\")\n        line: str = f\"{clock_name} &gt; {', '.join(stats_str)}\"\n        lines.append(line)\n    if len(self.clocks) == 1:\n        return f\"{header} {lines[0]}\"\n    return f\"{header}\\n\" + \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.TodoError","title":"TodoError","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>, default:                   <code>'not yet implemented'</code> )           \u2013            </li> <li> <code>assignee</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>assignee</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>message</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.TodoError.assignee","title":"assignee  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>assignee: str | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.TodoError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = 'not yet implemented'\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.TodoError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def __str__(self) -&gt; str:\n    msg: str = \"TODO\"\n    if self.assignee:\n        msg += f\"({self.assignee})\"\n    msg += f\": {self.message}\"\n    return msg\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.UnreachableError","title":"UnreachableError","text":"<p>               Bases: <code>AssertionError</code></p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>message</code>               (<code>str | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.UnreachableError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.UnreachableError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def __str__(self) -&gt; str:\n    msg: str = \"internal error: entered unreachable code\"\n    if self.message:\n        msg += f\": {self.message}\"\n    return msg\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions","title":"WadlerLindigOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>indent</code>               (<code>int</code>)           \u2013            </li> <li> <code>short_arrays</code>               (<code>bool</code>)           \u2013            </li> <li> <code>custom</code>               (<code>Callable[list, Optional[AbstractDoc]]</code>)           \u2013            </li> <li> <code>hide_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_type_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_dataclass_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_function_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>respect_pdoc</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays_threshold</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>custom</code>               (<code>Callable[[Any], AbstractDoc | None]</code>)           \u2013            </li> <li> <code>hide_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>indent</code>               (<code>int</code>)           \u2013            </li> <li> <code>respect_pdoc</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays_threshold</code>               (<code>int</code>)           \u2013            </li> <li> <code>show_dataclass_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_function_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_type_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.custom","title":"custom  <code>instance-attribute</code>","text":"<pre><code>custom: Callable[[Any], AbstractDoc | None]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.hide_defaults","title":"hide_defaults  <code>instance-attribute</code>","text":"<pre><code>hide_defaults: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.indent","title":"indent  <code>instance-attribute</code>","text":"<pre><code>indent: int\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.respect_pdoc","title":"respect_pdoc  <code>instance-attribute</code>","text":"<pre><code>respect_pdoc: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.short_arrays","title":"short_arrays  <code>instance-attribute</code>","text":"<pre><code>short_arrays: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.short_arrays_threshold","title":"short_arrays_threshold  <code>instance-attribute</code>","text":"<pre><code>short_arrays_threshold: int\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.show_dataclass_module","title":"show_dataclass_module  <code>instance-attribute</code>","text":"<pre><code>show_dataclass_module: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.show_function_module","title":"show_function_module  <code>instance-attribute</code>","text":"<pre><code>show_function_module: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.show_type_module","title":"show_type_module  <code>instance-attribute</code>","text":"<pre><code>show_type_module: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.WadlerLindigOptions.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width: int | None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.array_kind","title":"array_kind","text":"<pre><code>array_kind(obj: Any) -&gt; str | None\n</code></pre> Source code in <code>src/liblaf/grapes/typing/_array.py</code> <pre><code>def array_kind(obj: Any) -&gt; str | None:\n    for module, typename in [\n        (\"numpy\", \"ndarray\"),\n        (\"torch\", \"Tensor\"),\n        (\"jax\", \"Array\"),\n        (\"mlx.core\", \"array\"),\n    ]:\n        if module not in sys.modules:\n            continue\n        typ: type = getattr(sys.modules[module], typename)\n        if isinstance(obj, typ):\n            return module\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.as_iterable","title":"as_iterable","text":"<pre><code>as_iterable(\n    obj: Any, base_type: ClassInfo | None = (str, bytes)\n) -&gt; Iterable\n</code></pre> <p>.</p> <p>Examples:</p> <p>If <code>obj</code> is iterable, return an iterator over its items:</p> <pre><code>&gt;&gt;&gt; obj = (1, 2, 3)\n&gt;&gt;&gt; as_iterable(obj)\n(1, 2, 3)\n</code></pre> <p>If <code>obj</code> is not iterable, return a one-item iterable containing <code>obj</code>:</p> <pre><code>&gt;&gt;&gt; obj = 1\n&gt;&gt;&gt; as_iterable(obj)\n(1,)\n</code></pre> <p>If <code>obj</code> is <code>None</code>, return an empty iterable:</p> <pre><code>&gt;&gt;&gt; obj = None\n&gt;&gt;&gt; as_iterable(None)\n()\n</code></pre> <p>By default, binary and text strings are not considered iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_iterable(obj)\n('foo',)\n</code></pre> <p>If <code>base_type</code> is set, objects for which <code>isinstance(obj, base_type)</code> returns <code>True</code> won\u2019t be considered iterable.</p> <pre><code>&gt;&gt;&gt; obj = {\"a\": 1}\n&gt;&gt;&gt; as_iterable(obj)\n{'a': 1}\n&gt;&gt;&gt; as_iterable(obj, base_type=dict)  # Treat dicts as a unit\n({'a': 1},)\n</code></pre> <p>Set <code>base_type</code> to <code>None</code> to avoid any special handling and treat objects Python considers iterable as iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_iterable(obj, base_type=None)\n'foo'\n</code></pre> References <ol> <li><code>more_itertools.always_iterable</code></li> </ol> Source code in <code>src/liblaf/grapes/itertools/_as_iterable.py</code> <pre><code>def as_iterable(obj: Any, base_type: ClassInfo | None = (str, bytes)) -&gt; Iterable:\n    \"\"\".\n\n    Examples:\n        If `obj` is iterable, return an iterator over its items:\n\n        &gt;&gt;&gt; obj = (1, 2, 3)\n        &gt;&gt;&gt; as_iterable(obj)\n        (1, 2, 3)\n\n        If `obj` is not iterable, return a one-item iterable containing `obj`:\n\n        &gt;&gt;&gt; obj = 1\n        &gt;&gt;&gt; as_iterable(obj)\n        (1,)\n\n        If `obj` is `None`, return an empty iterable:\n\n        &gt;&gt;&gt; obj = None\n        &gt;&gt;&gt; as_iterable(None)\n        ()\n\n        By default, binary and text strings are not considered iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_iterable(obj)\n        ('foo',)\n\n        If `base_type` is set, objects for which `isinstance(obj, base_type)` returns ``True`` won't be considered iterable.\n\n        &gt;&gt;&gt; obj = {\"a\": 1}\n        &gt;&gt;&gt; as_iterable(obj)\n        {'a': 1}\n        &gt;&gt;&gt; as_iterable(obj, base_type=dict)  # Treat dicts as a unit\n        ({'a': 1},)\n\n        Set `base_type` to `None` to avoid any special handling and treat objects Python considers iterable as iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_iterable(obj, base_type=None)\n        'foo'\n\n    References:\n        1. [`more_itertools.always_iterable`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable)\n    \"\"\"\n    if obj is None:\n        return ()\n    if base_type is not None and isinstance(obj, base_type):\n        return (obj,)\n    if isinstance(obj, Iterable):\n        return obj\n    return (obj,)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.as_sequence","title":"as_sequence","text":"<pre><code>as_sequence(\n    obj: Any, base_type: ClassInfo | None = (str, bytes)\n) -&gt; Sequence\n</code></pre> <p>.</p> <p>Examples:</p> <p>If <code>obj</code> is iterable, return an iterator over its items:</p> <pre><code>&gt;&gt;&gt; obj = (1, 2, 3)\n&gt;&gt;&gt; as_sequence(obj)\n(1, 2, 3)\n</code></pre> <p>If <code>obj</code> is not iterable, return a one-item iterable containing <code>obj</code>:</p> <pre><code>&gt;&gt;&gt; obj = 1\n&gt;&gt;&gt; as_sequence(obj)\n(1,)\n</code></pre> <p>If <code>obj</code> is <code>None</code>, return an empty iterable:</p> <pre><code>&gt;&gt;&gt; obj = None\n&gt;&gt;&gt; as_sequence(None)\n()\n</code></pre> <p>By default, binary and text strings are not considered iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_sequence(obj)\n('foo',)\n</code></pre> <p>If <code>base_type</code> is set, objects for which <code>isinstance(obj, base_type)</code> returns <code>True</code> won\u2019t be considered iterable.</p> <pre><code>&gt;&gt;&gt; obj = {\"a\": 1}\n&gt;&gt;&gt; as_sequence(obj)\n({'a': 1},)\n&gt;&gt;&gt; as_sequence(obj, base_type=dict)  # Treat dicts as a unit\n({'a': 1},)\n</code></pre> <p>Set <code>base_type</code> to <code>None</code> to avoid any special handling and treat objects Python considers iterable as iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_sequence(obj, base_type=None)\n'foo'\n</code></pre> References <ol> <li><code>more_itertools.always_iterable</code></li> </ol> Source code in <code>src/liblaf/grapes/itertools/_as_sequence.py</code> <pre><code>def as_sequence(obj: Any, base_type: ClassInfo | None = (str, bytes)) -&gt; Sequence:\n    \"\"\".\n\n    Examples:\n        If `obj` is iterable, return an iterator over its items:\n\n        &gt;&gt;&gt; obj = (1, 2, 3)\n        &gt;&gt;&gt; as_sequence(obj)\n        (1, 2, 3)\n\n        If `obj` is not iterable, return a one-item iterable containing `obj`:\n\n        &gt;&gt;&gt; obj = 1\n        &gt;&gt;&gt; as_sequence(obj)\n        (1,)\n\n        If `obj` is `None`, return an empty iterable:\n\n        &gt;&gt;&gt; obj = None\n        &gt;&gt;&gt; as_sequence(None)\n        ()\n\n        By default, binary and text strings are not considered iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_sequence(obj)\n        ('foo',)\n\n        If `base_type` is set, objects for which `isinstance(obj, base_type)` returns ``True`` won't be considered iterable.\n\n        &gt;&gt;&gt; obj = {\"a\": 1}\n        &gt;&gt;&gt; as_sequence(obj)\n        ({'a': 1},)\n        &gt;&gt;&gt; as_sequence(obj, base_type=dict)  # Treat dicts as a unit\n        ({'a': 1},)\n\n        Set `base_type` to `None` to avoid any special handling and treat objects Python considers iterable as iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_sequence(obj, base_type=None)\n        'foo'\n\n    References:\n        1. [`more_itertools.always_iterable`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable)\n    \"\"\"\n    if obj is None:\n        return ()\n    if base_type is not None and isinstance(obj, base_type):\n        return (obj,)\n    if isinstance(obj, Sequence):\n        return obj\n    return (obj,)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.auto_repr","title":"auto_repr","text":"<pre><code>auto_repr(\n    cls: T,\n    *,\n    repr: bool | None = None,\n    pdoc: bool | None = None,\n) -&gt; T\n</code></pre><pre><code>auto_repr(\n    *, repr: bool | None = None, pdoc: bool | None = None\n) -&gt; Callable[[T], T]\n</code></pre> <pre><code>auto_repr(\n    cls: type | None = None,\n    *,\n    repr: bool | None = None,\n    pdoc: bool | None = None,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_auto_repr.py</code> <pre><code>def auto_repr(\n    cls: type | None = None,\n    *,\n    repr: bool | None = None,  # noqa: A002\n    pdoc: bool | None = None,\n) -&gt; Any:\n    if cls is None:\n        return functools.partial(auto_repr, repr=repr, pdoc=pdoc)\n    if repr or (repr is None and \"__repr__\" not in cls.__dict__):\n        cls.__repr__ = lambda self: pformat(self)  # pyright: ignore[reportAttributeAccessIssue]\n    if (pdoc or (pdoc is None and \"__pdoc__\" not in cls.__dict__)) and attrs.has(cls):\n        cls.__pdoc__ = pdoc_attrs  # pyright: ignore[reportAttributeAccessIssue]\n    return cls\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.cache","title":"cache","text":"<pre><code>cache(\n    func: Callable[P, T],\n    /,\n    *,\n    memory: Memory | None = ...,\n    ignore: list[str] | None = ...,\n    verbose: int | None = ...,\n    mmap_mode: Literal[\"r+\", \"r\", \"w+\", \"c\"] | None = ...,\n    cache_validation_callback: Callable[[Metadata], bool]\n    | None = ...,\n    bytes_limit: int | str | None = ...,\n    items_limit: int | None = ...,\n    age_limit: timedelta | None = ...,\n) -&gt; MemorizedFunc[P, T]\n</code></pre><pre><code>cache(\n    *,\n    memory: Memory | None = None,\n    ignore: list[str] | None = ...,\n    verbose: int | None = ...,\n    mmap_mode: Literal[\"r+\", \"r\", \"w+\", \"c\"] | None = ...,\n    cache_validation_callback: Callable[[Metadata], bool]\n    | None = ...,\n    bytes_limit: int | str | None = ...,\n    items_limit: int | None = ...,\n    age_limit: timedelta | None = ...,\n) -&gt; Callable[[Callable[P, T]], MemorizedFunc[P, T]]\n</code></pre> <pre><code>cache(\n    func: Callable | None = None, /, **kwargs: Any\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_cache.py</code> <pre><code>def cache(func: Callable | None = None, /, **kwargs: Any) -&gt; Any:\n    if func is None:\n        return functools.partial(cache, **kwargs)\n    memory: joblib.Memory | None = kwargs.pop(\"memory\", None)\n    if memory is None:\n        memory = new_memory()\n    cache_kwargs: dict[str, Any] = _filter_keys(\n        kwargs, (\"ignore\", \"verbose\", \"mmap_mode\", \"cache_validation_callback\")\n    )\n    reduce_size_kwargs: dict[str, Any] = _filter_keys(\n        kwargs, (\"bytes_limit\", \"items_limit\", \"age_limit\")\n    )\n    reduce_size_kwargs.setdefault(\"bytes_limit\", config.joblib.memory.bytes_limit)\n\n    @wrapt.function_wrapper\n    def wrapper[**P, T](\n        wrapped: Callable[P, T], _instance: Any, args: tuple, kwargs: dict[str, Any]\n    ) -&gt; T:\n        result: Any = wrapped(*args, **kwargs)\n        memory.reduce_size(**reduce_size_kwargs)\n        return result\n\n    func = memory.cache(func, **cache_kwargs)\n    func = wrapper(func)\n    wrapt_setattr(func, \"memory\", memory)\n    return func\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.choose_duration_format","title":"choose_duration_format","text":"<pre><code>choose_duration_format(seconds: float) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_duration.py</code> <pre><code>def choose_duration_format(seconds: float) -&gt; str:\n    for prec, threshold, fmt in FORMATS:\n        if round(seconds, prec) &lt; threshold:\n            return fmt\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.clock","title":"clock","text":"<pre><code>clock(name: ClockName = 'perf') -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_clock.py</code> <pre><code>def clock(name: ClockName = \"perf\") -&gt; float:\n    return CLOCK_REGISTRY[name]()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.clone_param_spec","title":"clone_param_spec","text":"<pre><code>clone_param_spec(\n    _func: Callable[P, T],\n) -&gt; Callable[[Any], Callable[P, T]]\n</code></pre> Source code in <code>src/liblaf/grapes/typing/_utils.py</code> <pre><code>def clone_param_spec[**P, T](\n    _func: Callable[P, T], /\n) -&gt; Callable[[Any], Callable[P, T]]:\n    def wrapper(wrapped: Any, /) -&gt; Callable[P, T]:\n        return wrapped\n\n    return wrapper\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.clone_signature","title":"clone_signature","text":"<pre><code>clone_signature(_source: C) -&gt; Callable[[Any], C]\n</code></pre> Source code in <code>src/liblaf/grapes/typing/_utils.py</code> <pre><code>def clone_signature[C](_source: C, /) -&gt; Callable[[Any], C]:\n    def wrapper(obj: Any) -&gt; C:\n        return obj\n\n    return wrapper\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.dec_hook","title":"dec_hook","text":"<pre><code>dec_hook(\n    typ: type,\n    obj: Any,\n    /,\n    *,\n    pydantic_options: PydanticModelValidateOptions\n    | None = None,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_decode.py</code> <pre><code>def dec_hook(\n    typ: type,\n    obj: Any,\n    /,\n    *,\n    pydantic_options: PydanticModelValidateOptions | None = None,\n) -&gt; Any:\n    if issubclass(typ, pydantic.BaseModel):\n        pydantic_options = pydantic_options or {}\n        return typ.model_validate(obj, **pydantic_options)\n    return typ(obj)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.deep_merge","title":"deep_merge","text":"<pre><code>deep_merge(\n    *mappings: Mapping[KT, VT], append_arrays: bool = False\n) -&gt; dict[KT, VT]\n</code></pre> Source code in <code>src/liblaf/grapes/itertools/_deep_merge.py</code> <pre><code>def deep_merge[KT, VT](\n    *mappings: Mapping[KT, VT], append_arrays: bool = False\n) -&gt; dict[KT, VT]:\n    result: dict[KT, VT] = {}\n    for mapping in mappings:\n        for key, value in mapping.items():\n            if key not in result:\n                result[key] = value\n            elif isinstance(result[key], Mapping):\n                result[key] = deep_merge(  # pyright: ignore[reportArgumentType]\n                    result[key],  # pyright: ignore[reportArgumentType]\n                    value,  # pyright: ignore[reportArgumentType]\n                    append_arrays=append_arrays,\n                )\n            elif append_arrays and isinstance(result[key], Sequence):\n                result[key] = [*result[key], *value]  # pyright: ignore[reportArgumentType, reportGeneralTypeIssues]\n    return result\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.enc_hook","title":"enc_hook","text":"<pre><code>enc_hook(obj: Any, /, **_kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_encode.py</code> <pre><code>@functools.singledispatch\ndef enc_hook(obj: Any, /, **_kwargs) -&gt; Any:\n    msg: str = f\"Objects of type {type(obj)} are not supported\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.first_not_none","title":"first_not_none","text":"<pre><code>first_not_none(*args: T | None) -&gt; T\n</code></pre> <p>Returns the first <code>not None</code> value in the <code>args</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; first_not_none(1, 2)\n1\n&gt;&gt;&gt; first_not_none(None, 1)\n1\n</code></pre> References <ol> <li><code>more_itertools.first_true</code></li> </ol> Source code in <code>src/liblaf/grapes/itertools/_first_not_none.py</code> <pre><code>def first_not_none[T](*args: T | None) -&gt; T:\n    \"\"\"Returns the first `not None` value in the `args`.\n\n    Examples:\n        &gt;&gt;&gt; first_not_none(1, 2)\n        1\n        &gt;&gt;&gt; first_not_none(None, 1)\n        1\n\n    References:\n        1. [`more_itertools.first_true`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.first_true)\n    \"\"\"\n    return next(arg for arg in args if arg is not None)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.get_console","title":"get_console  <code>cached</code>","text":"<pre><code>get_console(**kwargs) -&gt; Console\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_console.py</code> <pre><code>@clone_param_spec(Console)\n@functools.cache\ndef get_console(**kwargs) -&gt; Console:\n    if kwargs.get(\"theme\") is None:\n        kwargs[\"theme\"] = default_theme()\n    file: IO[str] | None = kwargs.get(\"file\")\n    stderr: bool = file is None and kwargs.get(\"stderr\", False)\n    stdout: bool = file is None and not stderr\n    if (\n        (stdout and not sys.stdout.isatty())\n        or (stderr and not sys.stderr.isatty())\n        or (file is not None and not os.isatty(file.fileno()))\n    ):\n        kwargs.setdefault(\"width\", 128)\n    if stdout:\n        rich.reconfigure(**kwargs)\n        return rich.get_console()\n    return Console(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.get_timer","title":"get_timer","text":"<pre><code>get_timer(wrapper: Any) -&gt; BaseTimer\n</code></pre><pre><code>get_timer(wrapper: Any, default: T) -&gt; BaseTimer | T\n</code></pre> <pre><code>get_timer(\n    wrapper: Any, default: Any | MISSING = MISSING\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_utils.py</code> <pre><code>def get_timer(wrapper: Any, default: Any | MISSING = MISSING) -&gt; Any:\n    if default is MISSING:\n        return ft.wrapt_getattr(wrapper, \"timer\")\n    return ft.wrapt_getattr(wrapper, \"timer\", default)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.has_ansi","title":"has_ansi","text":"<pre><code>has_ansi(s: str) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_ansi.py</code> <pre><code>def has_ansi(s: str, /) -&gt; bool:\n    return \"\\x1b\" in s\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.has_module","title":"has_module  <code>cached</code>","text":"<pre><code>has_module(name: str, package: str | None = None) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/deps/_has_module.py</code> <pre><code>@functools.lru_cache\ndef has_module(name: str, package: str | None = None) -&gt; bool:\n    return importlib.util.find_spec(name, package) is not None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.len_or_none","title":"len_or_none","text":"<pre><code>len_or_none(iterable: Iterable) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/itertools/_len_or_none.py</code> <pre><code>def len_or_none(iterable: Iterable) -&gt; int | None:\n    try:\n        return len(iterable)  # pyright: ignore[reportArgumentType]\n    except TypeError:\n        return None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.load","title":"load","text":"<pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    force_ext: str | None = None,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n) -&gt; Any\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    force_ext: str | None = None,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: type[T],\n) -&gt; T\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    force_ext: str | None = None,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: Any,\n) -&gt; Any\n</code></pre> <pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    force_ext: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_load.py</code> <pre><code>def load(path: PathLike, /, *, force_ext: str | None = None, **kwargs) -&gt; Any:\n    path = Path(path)\n    ext: str = force_ext or path.suffix\n    return readers[ext](path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.nop","title":"nop","text":"<pre><code>nop(*args, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/sentinel/_function.py</code> <pre><code>def nop(*args, **kwargs) -&gt; None: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.optional_imports","title":"optional_imports","text":"<pre><code>optional_imports(\n    package: str, extra: str\n) -&gt; Generator[None]\n</code></pre> Source code in <code>src/liblaf/grapes/deps/_optional_imports.py</code> <pre><code>@contextlib.contextmanager\ndef optional_imports(package: str, extra: str) -&gt; Generator[None]:\n    try:\n        yield\n    except ImportError as err:\n        epy.reraise(\n            err, suffix=f\"Make sure to install `{package}` with the `{extra}` extra.\"\n        )\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.parallel","title":"parallel","text":"<pre><code>parallel(\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\"list\"] = \"list\",\n    total: int | None = None,\n) -&gt; list[T]\n</code></pre><pre><code>parallel(\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\"generator\", \"generator_unordered\"],\n    total: int | None = None,\n) -&gt; Generator[T]\n</code></pre> <pre><code>parallel(\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\n        \"list\", \"generator\", \"generator_unordered\"\n    ] = \"list\",\n    total: int | None = None,\n) -&gt; list[T] | Generator[T]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_joblib.py</code> <pre><code>def parallel[T](\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\"list\", \"generator\", \"generator_unordered\"] = \"list\",\n    total: int | None = None,\n) -&gt; list[T] | Generator[T]:\n    for iterable in iterables:\n        if total is not None:\n            break\n        total = _it.len_or_none(iterable)\n\n    parallel = joblib.Parallel(return_as=return_as)\n\n    task_id: TaskID | None = None\n    if progress is None:\n        progress = Progress()\n    progress: Progress | contextlib.nullcontext\n    if progress:\n        task_id = progress.add_task(description=description, total=total)\n    else:\n        progress = contextlib.nullcontext()\n    parallel.print_progress = functools.partial(\n        print_progress, self=parallel, progress=progress, task_id=task_id\n    )\n\n    jobs = map(joblib.delayed(fn), *iterables)\n    match return_as:\n        case \"list\":\n            return as_list(parallel, jobs, progress=progress)\n        case \"generator\" | \"generator_unordered\":\n            return as_generator(parallel, jobs, progress=progress)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pdoc_attrs","title":"pdoc_attrs","text":"<pre><code>pdoc_attrs(\n    self: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; AbstractDoc\n</code></pre> <p>.</p> References <ol> <li>https://github.com/patrick-kidger/wadler_lindig/blob/0226340d56f0c18e10cd4d375cf7ea25818359b8/wadler_lindig/_definitions.py#L308-L326</li> </ol> Source code in <code>src/liblaf/grapes/pretty/_wadler_lindig.py</code> <pre><code>def pdoc_attrs(self: Any, **kwargs: Unpack[WadlerLindigOptions]) -&gt; wl.AbstractDoc:\n    \"\"\".\n\n    References:\n        1. &lt;https://github.com/patrick-kidger/wadler_lindig/blob/0226340d56f0c18e10cd4d375cf7ea25818359b8/wadler_lindig/_definitions.py#L308-L326&gt;\n    \"\"\"\n    kwargs: WadlerLindigOptions = _make_kwargs(kwargs)\n    cls: type = type(self)\n    objs: list[tuple[str, Any]] = []\n    for field in attrs.fields(cls):\n        field: attrs.Attribute\n        if not field.repr:\n            continue\n        value: Any = getattr(self, field.name, UNINITIALIZED)\n        if kwargs.get(\"hide_defaults\", True) and value is field.default:\n            continue\n        objs.append((field.name, value))\n    name_kwargs: dict[str, Any] = toolz.assoc(\n        kwargs, \"show_type_module\", kwargs.get(\"show_dataclass_module\", False)\n    )\n    return wl.bracketed(\n        begin=wl.pdoc(cls, **name_kwargs) + wl.TextDoc(\"(\"),\n        docs=wl.named_objs(objs, **kwargs),\n        sep=wl.comma,\n        end=wl.TextDoc(\")\"),\n        indent=kwargs.get(\"indent\", 2),\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pdoc_custom","title":"pdoc_custom","text":"<pre><code>pdoc_custom(\n    obj: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; AbstractDoc | None\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_wadler_lindig.py</code> <pre><code>@functools.singledispatch\ndef pdoc_custom(\n    obj: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; wl.AbstractDoc | None:\n    if hasattr(obj, \"__pdoc__\"):\n        return None\n    if attrs.has(type(obj)):\n        return pdoc_attrs(obj, **kwargs)\n    if (size := _array_size(obj)) is not None:\n        if kwargs.get(\"short_arrays\") is None:\n            try:\n                kwargs[\"short_arrays\"] = size &gt; kwargs.get(\n                    \"short_arrays_threshold\", 100\n                )\n            except TypeError:\n                kwargs[\"short_arrays\"] = True\n        return wl.pdoc(obj, **kwargs)\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pformat","title":"pformat","text":"<pre><code>pformat(\n    obj: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_wadler_lindig.py</code> <pre><code>@functools.singledispatch\ndef pformat(obj: Any, **kwargs: Unpack[WadlerLindigOptions]) -&gt; str:\n    kwargs: WadlerLindigOptions = _make_kwargs(kwargs)\n    if kwargs.get(\"width\") is None:\n        kwargs[\"width\"] = get_console(stderr=True).width\n    if kwargs.get(\"custom\") is None:\n        kwargs[\"custom\"] = functools.partial(pdoc_custom, **kwargs)\n    return wl.pformat(obj, **kwargs)  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pretty_call","title":"pretty_call","text":"<pre><code>pretty_call(\n    func: Callable,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    **wl_kwargs,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_call.py</code> <pre><code>def pretty_call(\n    func: Callable,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    **wl_kwargs,\n) -&gt; str:\n    func = inspect.unwrap(func)\n    args, kwargs = _bind_safe(func, args, kwargs)\n    return pformat(PrettyCall(func, args, kwargs), **wl_kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pretty_duration","title":"pretty_duration","text":"<pre><code>pretty_duration(\n    seconds: float, fmt: str | None = None\n) -&gt; str\n</code></pre> <p>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pretty_duration(math.nan)\n'?? s'\n&gt;&gt;&gt; pretty_duration(1e-12)\n'0.00 ns'\n&gt;&gt;&gt; pretty_duration(1e-11)\n'0.01 ns'\n&gt;&gt;&gt; pretty_duration(1e-10)\n'0.10 ns'\n&gt;&gt;&gt; pretty_duration(1e-9)\n'1.00 ns'\n&gt;&gt;&gt; pretty_duration(1e-8)\n'10.0 ns'\n&gt;&gt;&gt; pretty_duration(1e-7)\n'100. ns'\n&gt;&gt;&gt; pretty_duration(1e-6)\n'1.00 \u00b5s'\n&gt;&gt;&gt; pretty_duration(1e-5)\n'10.0 \u00b5s'\n&gt;&gt;&gt; pretty_duration(1e-4)\n'100. \u00b5s'\n&gt;&gt;&gt; pretty_duration(1e-3)\n'1.00 ms'\n&gt;&gt;&gt; pretty_duration(1e-2)\n'10.0 ms'\n&gt;&gt;&gt; pretty_duration(1e-1)\n'100. ms'\n&gt;&gt;&gt; pretty_duration(1.0)\n'1.00 s'\n&gt;&gt;&gt; pretty_duration(1e1)\n'10.0 s'\n&gt;&gt;&gt; pretty_duration(1e2)\n'01:40'\n&gt;&gt;&gt; pretty_duration(1e3)\n'16:40'\n&gt;&gt;&gt; pretty_duration(1e4)\n'02:46:40'\n&gt;&gt;&gt; pretty_duration(1e5)\n'1d,03:46:40'\n&gt;&gt;&gt; pretty_duration(1e6)\n'11d,13:46:40'\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_duration.py</code> <pre><code>def pretty_duration(seconds: float, fmt: str | None = None) -&gt; str:  # noqa: C901, PLR0911, PLR0912\n    \"\"\".\n\n    Examples:\n        &gt;&gt;&gt; pretty_duration(math.nan)\n        '?? s'\n        &gt;&gt;&gt; pretty_duration(1e-12)\n        '0.00 ns'\n        &gt;&gt;&gt; pretty_duration(1e-11)\n        '0.01 ns'\n        &gt;&gt;&gt; pretty_duration(1e-10)\n        '0.10 ns'\n        &gt;&gt;&gt; pretty_duration(1e-9)\n        '1.00 ns'\n        &gt;&gt;&gt; pretty_duration(1e-8)\n        '10.0 ns'\n        &gt;&gt;&gt; pretty_duration(1e-7)\n        '100. ns'\n        &gt;&gt;&gt; pretty_duration(1e-6)\n        '1.00 \u00b5s'\n        &gt;&gt;&gt; pretty_duration(1e-5)\n        '10.0 \u00b5s'\n        &gt;&gt;&gt; pretty_duration(1e-4)\n        '100. \u00b5s'\n        &gt;&gt;&gt; pretty_duration(1e-3)\n        '1.00 ms'\n        &gt;&gt;&gt; pretty_duration(1e-2)\n        '10.0 ms'\n        &gt;&gt;&gt; pretty_duration(1e-1)\n        '100. ms'\n        &gt;&gt;&gt; pretty_duration(1.0)\n        '1.00 s'\n        &gt;&gt;&gt; pretty_duration(1e1)\n        '10.0 s'\n        &gt;&gt;&gt; pretty_duration(1e2)\n        '01:40'\n        &gt;&gt;&gt; pretty_duration(1e3)\n        '16:40'\n        &gt;&gt;&gt; pretty_duration(1e4)\n        '02:46:40'\n        &gt;&gt;&gt; pretty_duration(1e5)\n        '1d,03:46:40'\n        &gt;&gt;&gt; pretty_duration(1e6)\n        '11d,13:46:40'\n    \"\"\"\n    if not math.isfinite(seconds):\n        return \"?? s\"\n    if fmt is None:\n        fmt = choose_duration_format(seconds)\n    fmt = fmt.replace(\"us\", \"\u00b5s\")\n    match fmt:\n        case \"9.99 ns\":\n            return f\"{seconds * 1e9:#.2f} ns\"\n        case \"99.9 ns\":\n            return f\"{seconds * 1e9:#.1f} ns\"\n        case \"999. ns\":\n            return f\"{seconds * 1e9:#.0f} ns\"\n        case \"9.99 \u00b5s\":\n            return f\"{seconds * 1e6:#.2f} \u00b5s\"\n        case \"99.9 \u00b5s\":\n            return f\"{seconds * 1e6:#.1f} \u00b5s\"\n        case \"999. \u00b5s\":\n            return f\"{seconds * 1e6:#.0f} \u00b5s\"\n        case \"9.99 ms\":\n            return f\"{seconds * 1e3:#.2f} ms\"\n        case \"99.9 ms\":\n            return f\"{seconds * 1e3:#.1f} ms\"\n        case \"999. ms\":\n            return f\"{seconds * 1e3:#.0f} ms\"\n        case \"9.99 s\":\n            return f\"{seconds:#.2f} s\"\n        case \"99.9 s\":\n            return f\"{seconds:#.1f} s\"\n        case \"999. s\":\n            return f\"{seconds:#.0f} s\"\n        case \"59:59\":\n            minutes: int\n            seconds: int\n            seconds = round(seconds)\n            minutes, seconds = divmod(seconds, 60)\n            return f\"{minutes:02d}:{seconds:02d}\"\n        case \"23:59:59\":\n            hours: int\n            minutes: int\n            seconds = round(seconds)\n            hours, seconds = divmod(seconds, 3600)\n            minutes, seconds = divmod(seconds, 60)\n            return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n        case \"1d,23:59:59\":\n            days: int\n            hours: int\n            minutes: int\n            seconds = round(seconds)\n            days, seconds = divmod(seconds, 86400)\n            hours, seconds = divmod(seconds, 3600)\n            minutes, seconds = divmod(seconds, 60)\n            return f\"{days}d,{hours:02d}:{minutes:02d}:{seconds:02d}\"\n        case _:\n            raise MatchError(fmt, \"format\")\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pretty_func","title":"pretty_func","text":"<pre><code>pretty_func(func: Callable) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_func.py</code> <pre><code>def pretty_func(func: Callable, /) -&gt; str:\n    name: str = get_name(func)\n    return f\"{name}()\"\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.pretty_throughput","title":"pretty_throughput","text":"<pre><code>pretty_throughput(value: float, unit: str = '') -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_throughput.py</code> <pre><code>def pretty_throughput(value: float, unit: str = \"\") -&gt; str:\n    throughput: about_time.HumanThroughput = about_time.HumanThroughput(value, unit)\n    return throughput.as_human()\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.rich_location","title":"rich_location","text":"<pre><code>rich_location(\n    name: str | None,\n    function: str | None,\n    line: int | None,\n    file: PathLike | None = None,\n    *,\n    enable_link: bool = True,\n    width: int | None = None,\n) -&gt; Text\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_location.py</code> <pre><code>def rich_location(\n    name: str | None,\n    function: str | None,\n    line: int | None,\n    file: PathLike | None = None,\n    *,\n    enable_link: bool = True,\n    width: int | None = None,\n) -&gt; Text:\n    name = name or \"&lt;unknown&gt;\"\n    function = function or \"&lt;unknown&gt;\"\n    line = line or 0\n    file: Path | None = Path(file) if file is not None else None\n    func_line: str = f\":{function}:{line}\"\n    if width and len(name) + len(func_line) &gt; width:\n        name = name[: width - len(func_line) - 1] + \"\u2026\"\n    if enable_link and file is not None and file.exists():\n        return Text(\n            f\"{name}:{function}:{line}\", style=Style(link=f\"{file.as_uri()}#{line}\")\n        )\n    return Text(f\"{name}:{function}:{line}\")\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.save","title":"save","text":"<pre><code>save(\n    path: PathLike,\n    obj: Any,\n    /,\n    *,\n    enc_hook: EncHook | None = ...,\n    force_ext: str | None = None,\n    order: Literal[\"deterministic\", \"sorted\"] | None = None,\n    pydantic: PydanticModelDumpOptions | None = None,\n) -&gt; None\n</code></pre> <pre><code>save(\n    path: PathLike,\n    obj: Any,\n    /,\n    force_ext: str | None = None,\n    **kwargs,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_save.py</code> <pre><code>def save(path: PathLike, obj: Any, /, force_ext: str | None = None, **kwargs) -&gt; None:\n    path = Path(path)\n    ext: str = force_ext or path.suffix\n    return writers[ext](path, obj, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.timer","title":"timer","text":"<pre><code>timer(\n    *,\n    name: str | None = ...,\n    clocks: Sequence[ClockName] = ...,\n    cb_finish: Callback | None = ...,\n    cb_start: Callback | None = ...,\n    cb_stop: Callback | None = ...,\n) -&gt; Timer\n</code></pre><pre><code>timer(\n    callable: C,\n    /,\n    *,\n    name: str | None = ...,\n    clocks: Sequence[ClockName] = ...,\n    cb_start: Callback | None = ...,\n    cb_stop: Callback | None = ...,\n    cb_finish: Callback | None = ...,\n) -&gt; C\n</code></pre><pre><code>timer(\n    iterable: I,\n    /,\n    *,\n    name: str | None = ...,\n    clocks: Sequence[ClockName] = ...,\n    cb_start: Callback | None = ...,\n    cb_stop: Callback | None = ...,\n    cb_finish: Callback | None = ...,\n) -&gt; I\n</code></pre> <pre><code>timer(\n    func_or_iterable: Callable | Iterable | None = None,\n    /,\n    **kwargs,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_main.py</code> <pre><code>def timer(func_or_iterable: Callable | Iterable | None = None, /, **kwargs) -&gt; Any:\n    timer = Timer(**kwargs)\n    if func_or_iterable is None:\n        return timer\n    return timer(func_or_iterable)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.todo","title":"todo","text":"<pre><code>todo(\n    message: str = \"not yet implemented\",\n    assignee: str | None = None,\n) -&gt; Never\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def todo(message: str = \"not yet implemented\", assignee: str | None = None) -&gt; Never:\n    raise TodoError(message=message, assignee=assignee)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.track","title":"track","text":"<pre><code>track(\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    progress: Progress | None = None,\n    timer: Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_track.py</code> <pre><code>def track[T](\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    progress: Progress | None = None,\n    timer: timing.Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]:\n    __tracebackhide__ = True\n    if timer is None:\n        timer = timing.timer(name=description)\n    if progress is None:\n        progress = Progress(timer=timer)\n    with progress:\n        yield from progress.track(\n            sequence,\n            total=total,\n            completed=completed,\n            description=description,\n            update_period=update_period,\n            timer=timer,\n        )\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.try_import","title":"try_import","text":"<pre><code>try_import(\n    name: str, package: str | None = None\n) -&gt; ModuleType | None\n</code></pre> Source code in <code>src/liblaf/grapes/deps/_try_import.py</code> <pre><code>def try_import(name: str, package: str | None = None) -&gt; types.ModuleType | None:\n    try:\n        return importlib.import_module(name, package)\n    except ImportError:\n        return None\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.unreachable","title":"unreachable","text":"<pre><code>unreachable(message: str | None = None) -&gt; Never\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def unreachable(message: str | None = None) -&gt; Never:\n    raise UnreachableError(message=message)\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.wrapt_getattr","title":"wrapt_getattr","text":"<pre><code>wrapt_getattr(obj: Any, name: str) -&gt; Any\n</code></pre><pre><code>wrapt_getattr(obj: Any, name: str, default: T) -&gt; Any | T\n</code></pre> <pre><code>wrapt_getattr(\n    obj: Any, name: str, default: Any = MISSING\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_wrapt.py</code> <pre><code>def wrapt_getattr(obj: Any, name: str, default: Any = MISSING, /) -&gt; Any:\n    name = f\"_self_{name}\"\n    try:\n        return getattr(obj, name)\n    except AttributeError:\n        parent: Any = getattr(obj, \"_self_parent\", None)\n        if parent is None:\n            if default is MISSING:\n                raise\n            return default\n        if hasattr(parent, name):\n            return getattr(parent, name)\n        if default is MISSING:\n            raise\n        return default\n</code></pre>"},{"location":"reference/liblaf/grapes/#liblaf.grapes.wrapt_setattr","title":"wrapt_setattr","text":"<pre><code>wrapt_setattr(obj: Any, name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_wrapt.py</code> <pre><code>def wrapt_setattr(obj: Any, name: str, value: Any, /) -&gt; None:\n    name = f\"_self_{name}\"\n    setattr(obj, name, value)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/","title":"conf","text":""},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf","title":"liblaf.grapes.conf","text":"<p>Classes:</p> <ul> <li> <code>BaseConfig</code>           \u2013            </li> <li> <code>BaseModel</code>           \u2013            </li> <li> <code>Config</code>           \u2013            </li> <li> <code>ConfigJoblib</code>           \u2013            </li> <li> <code>ConfigJoblibMemory</code>           \u2013            </li> <li> <code>ConfigLogging</code>           \u2013            </li> <li> <code>ConfigPretty</code>           \u2013            <p>.</p> </li> <li> <code>ConfigTraceback</code>           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>config</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.config","title":"config  <code>module-attribute</code>","text":"<pre><code>config = Config()\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.BaseConfig","title":"BaseConfig","text":"<p>               Bases: <code>OverridesMixin</code>, <code>BaseSettings</code></p> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.BaseConfig.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.BaseConfig.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.BaseModel","title":"BaseModel  <code>pydantic-model</code>","text":"<p>               Bases: <code>OverridesMixin</code>, <code>BaseModel</code></p> Show JSON schema: <pre><code>{\n  \"properties\": {},\n  \"title\": \"BaseModel\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Config:</p> <ul> <li><code>validate_assignment</code>: <code>True</code></li> <li><code>arbitrary_types_allowed</code>: <code>True</code></li> <li><code>validate_default</code>: <code>True</code></li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.BaseModel.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = ConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.BaseModel.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config","title":"Config","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Parameters:</p> <ul> <li> <code>joblib</code>               (<code>ConfigJoblib</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>logging</code>               (<code>ConfigLogging</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>pretty</code>               (<code>ConfigPretty</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            <p>.</p> <p>References:     1. wadler_lindig.pformat</p> </li> <li> <code>traceback</code>               (<code>ConfigTraceback</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>joblib</code>               (<code>ConfigJoblib</code>)           \u2013            </li> <li> <code>logging</code>               (<code>ConfigLogging</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>pretty</code>               (<code>ConfigPretty</code>)           \u2013            </li> <li> <code>traceback</code>               (<code>ConfigTraceback</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config.joblib","title":"joblib  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>joblib: ConfigJoblib = Field(default_factory=ConfigJoblib)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: ConfigLogging = Field(\n    default_factory=ConfigLogging\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config.pretty","title":"pretty  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pretty: ConfigPretty = Field(default_factory=ConfigPretty)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config.traceback","title":"traceback  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>traceback: ConfigTraceback = Field(\n    default_factory=ConfigTraceback\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.Config.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblib","title":"ConfigJoblib","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Parameters:</p> <ul> <li> <code>memory</code>               (<code>ConfigJoblibMemory</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>memory</code>               (<code>ConfigJoblibMemory</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblib.memory","title":"memory  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>memory: ConfigJoblibMemory = Field(\n    default_factory=ConfigJoblibMemory\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblib.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblib.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblibMemory","title":"ConfigJoblibMemory","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Parameters:</p> <ul> <li> <code>location</code>               (<code>Path</code>, default:                   <code>PosixPath('/home/runner/.cache/joblib')</code> )           \u2013            </li> <li> <code>bytes_limit</code>               (<code>int | str | None</code>, default:                   <code>'4G'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>bytes_limit</code>               (<code>int | str | None</code>)           \u2013            </li> <li> <code>location</code>               (<code>Path</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblibMemory.bytes_limit","title":"bytes_limit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>bytes_limit: int | str | None = '4G'\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblibMemory.location","title":"location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>location: Path = Field(default_factory=_default_location)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblibMemory.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    env_prefix=\"JOBLIB_MEMORY_\"\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigJoblibMemory.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigLogging","title":"ConfigLogging","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Parameters:</p> <ul> <li> <code>file</code>               (<code>Path | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>level</code>               (<code>int | str</code>, default:                   <code>'TRACE'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>file</code>               (<code>Path | None</code>)           \u2013            </li> <li> <code>level</code>               (<code>int | str</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigLogging.file","title":"file  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>file: Path | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigLogging.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: int | str = 'TRACE'\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigLogging.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(env_prefix='LOG_')\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigLogging.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty","title":"ConfigPretty","text":"<p>               Bases: <code>BaseConfig</code></p> <p>.</p> References <ol> <li>wadler_lindig.pformat</li> </ol> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>a best-effort maximum width to allow. May be exceeded if there are unbroken pieces of text which are wider than this.</p> </li> <li> <code>indent</code>               (<code>int</code>, default:                   <code>2</code> )           \u2013            <p>when the contents of a structured type are too large to fit on one line, they will be indented by this amount and placed on separate lines.</p> </li> <li> <code>short_arrays</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>whether to print a NumPy array / PyTorch tensor / JAX array as a short summary of the form <code>f32[3,4]</code> (here indicating a <code>float32</code> matrix of shape <code>(3, 4)</code>)</p> </li> <li> <code>hide_defaults</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to show the default values of dataclass fields.</p> </li> <li> <code>show_type_module</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>whether to show the name of the module for a type: <code>somelib.SomeClass</code> versus <code>SomeClass</code>.</p> </li> <li> <code>show_dataclass_module</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to show the name of the module for a dataclass instance: <code>somelib.SomeClass()</code> versus <code>SomeClass()</code>.</p> </li> <li> <code>show_function_module</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>whether to show the name of the module for a function: <code>&lt;function some_fn&gt;</code> versus <code>&lt;function somelib.some_fn&gt;</code>.</p> </li> <li> <code>respect_pdoc</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>short_arrays_threshold</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>hide_defaults</code>               (<code>bool</code>)           \u2013            <p>whether to show the default values of dataclass fields.</p> </li> <li> <code>indent</code>               (<code>int</code>)           \u2013            <p>when the contents of a structured type are too large to fit on one line, they will be indented by this amount and placed on separate lines.</p> </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>respect_pdoc</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays</code>               (<code>bool | None</code>)           \u2013            <p>whether to print a NumPy array / PyTorch tensor / JAX array as a short summary of the form <code>f32[3,4]</code> (here indicating a <code>float32</code> matrix of shape <code>(3, 4)</code>)</p> </li> <li> <code>short_arrays_threshold</code>               (<code>int</code>)           \u2013            </li> <li> <code>show_dataclass_module</code>               (<code>bool</code>)           \u2013            <p>whether to show the name of the module for a dataclass instance: <code>somelib.SomeClass()</code> versus <code>SomeClass()</code>.</p> </li> <li> <code>show_function_module</code>               (<code>bool</code>)           \u2013            <p>whether to show the name of the module for a function: <code>&lt;function some_fn&gt;</code> versus <code>&lt;function somelib.some_fn&gt;</code>.</p> </li> <li> <code>show_type_module</code>               (<code>bool</code>)           \u2013            <p>whether to show the name of the module for a type: <code>somelib.SomeClass</code> versus <code>SomeClass</code>.</p> </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            <p>a best-effort maximum width to allow. May be exceeded if there are unbroken pieces of text which are wider than this.</p> </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.hide_defaults","title":"hide_defaults  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>hide_defaults: bool = True\n</code></pre> <p>whether to show the default values of dataclass fields.</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.indent","title":"indent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>indent: int = 2\n</code></pre> <p>when the contents of a structured type are too large to fit on one line, they will be indented by this amount and placed on separate lines.</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(\n    validate_assignment=True,\n    arbitrary_types_allowed=True,\n    validate_default=True,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.respect_pdoc","title":"respect_pdoc  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>respect_pdoc: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.short_arrays","title":"short_arrays  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>short_arrays: bool | None = None\n</code></pre> <p>whether to print a NumPy array / PyTorch tensor / JAX array as a short summary of the form <code>f32[3,4]</code> (here indicating a <code>float32</code> matrix of shape <code>(3, 4)</code>)</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.short_arrays_threshold","title":"short_arrays_threshold  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>short_arrays_threshold: int = 100\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.show_dataclass_module","title":"show_dataclass_module  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_dataclass_module: bool = False\n</code></pre> <p>whether to show the name of the module for a dataclass instance: <code>somelib.SomeClass()</code> versus <code>SomeClass()</code>.</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.show_function_module","title":"show_function_module  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_function_module: bool = False\n</code></pre> <p>whether to show the name of the module for a function: <code>&lt;function some_fn&gt;</code> versus <code>&lt;function somelib.some_fn&gt;</code>.</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.show_type_module","title":"show_type_module  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_type_module: bool = True\n</code></pre> <p>whether to show the name of the module for a type: <code>somelib.SomeClass</code> versus <code>SomeClass</code>.</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | None = None\n</code></pre> <p>a best-effort maximum width to allow. May be exceeded if there are unbroken pieces of text which are wider than this.</p>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigPretty.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback","title":"ConfigTraceback","text":"<p>               Bases: <code>BaseConfig</code></p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>show_locals</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>locals_hide_sunder</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>suppress</code>               (<code>list[str]</code>, default:                   <code>['comet_ml', 'liblaf.cherries', 'pydantic', 'rich.progress']</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>overrides</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>locals_hide_sunder</code>               (<code>bool</code>)           \u2013            </li> <li> <code>model_config</code>           \u2013            </li> <li> <code>show_locals</code>               (<code>bool</code>)           \u2013            </li> <li> <code>suppress</code>               (<code>list[str]</code>)           \u2013            </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback.locals_hide_sunder","title":"locals_hide_sunder  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>locals_hide_sunder: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback.model_config","title":"model_config  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_config = SettingsConfigDict(env_prefix='TRACEBACK_')\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback.show_locals","title":"show_locals  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>show_locals: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback.suppress","title":"suppress  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>suppress: list[str] = Field(\n    default=[\n        \"comet_ml\",\n        \"liblaf.cherries\",\n        \"pydantic\",\n        \"rich.progress\",\n    ]\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/conf/#liblaf.grapes.conf.ConfigTraceback.overrides","title":"overrides","text":"<pre><code>overrides(**kwargs) -&gt; Generator[Self]\n</code></pre> Source code in <code>src/liblaf/grapes/conf/_base.py</code> <pre><code>@contextlib.contextmanager\ndef overrides(self, **kwargs) -&gt; Generator[Self]:\n    backup: dict[str, Any] = {}\n    for k, v in kwargs.items():\n        backup[k] = getattr(self, k)\n        setattr(self, k, v)\n    try:\n        yield self\n    finally:\n        for k, v in backup.items():\n            setattr(self, k, v)\n</code></pre>"},{"location":"reference/liblaf/grapes/deps/","title":"deps","text":""},{"location":"reference/liblaf/grapes/deps/#liblaf.grapes.deps","title":"liblaf.grapes.deps","text":"<p>This module provides utility functions for handling optional imports and checking module availability.</p> <p>Functions:</p> <ul> <li> <code>has_module</code>             \u2013              </li> <li> <code>optional_imports</code>             \u2013              </li> <li> <code>try_import</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/deps/#liblaf.grapes.deps.has_module","title":"has_module  <code>cached</code>","text":"<pre><code>has_module(name: str, package: str | None = None) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/deps/_has_module.py</code> <pre><code>@functools.lru_cache\ndef has_module(name: str, package: str | None = None) -&gt; bool:\n    return importlib.util.find_spec(name, package) is not None\n</code></pre>"},{"location":"reference/liblaf/grapes/deps/#liblaf.grapes.deps.optional_imports","title":"optional_imports","text":"<pre><code>optional_imports(\n    package: str, extra: str\n) -&gt; Generator[None]\n</code></pre> Source code in <code>src/liblaf/grapes/deps/_optional_imports.py</code> <pre><code>@contextlib.contextmanager\ndef optional_imports(package: str, extra: str) -&gt; Generator[None]:\n    try:\n        yield\n    except ImportError as err:\n        epy.reraise(\n            err, suffix=f\"Make sure to install `{package}` with the `{extra}` extra.\"\n        )\n</code></pre>"},{"location":"reference/liblaf/grapes/deps/#liblaf.grapes.deps.try_import","title":"try_import","text":"<pre><code>try_import(\n    name: str, package: str | None = None\n) -&gt; ModuleType | None\n</code></pre> Source code in <code>src/liblaf/grapes/deps/_try_import.py</code> <pre><code>def try_import(name: str, package: str | None = None) -&gt; types.ModuleType | None:\n    try:\n        return importlib.import_module(name, package)\n    except ImportError:\n        return None\n</code></pre>"},{"location":"reference/liblaf/grapes/env/","title":"env","text":""},{"location":"reference/liblaf/grapes/env/#liblaf.grapes.env","title":"liblaf.grapes.env","text":"<p>Initialize and return an environment configuration.</p> <p>Functions:</p> <ul> <li> <code>in_ci</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/env/#liblaf.grapes.env.in_ci","title":"in_ci","text":"<pre><code>in_ci() -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/env/_ci.py</code> <pre><code>def in_ci() -&gt; bool:\n    return env.bool(\"CI\", False) or env.bool(\"GITHUB_ACTIONS\", False)\n</code></pre>"},{"location":"reference/liblaf/grapes/error/","title":"error","text":""},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error","title":"liblaf.grapes.error","text":"<p>Classes:</p> <ul> <li> <code>DispatchLookupError</code>           \u2013            </li> <li> <code>MatchError</code>           \u2013            </li> <li> <code>TodoError</code>           \u2013            </li> <li> <code>UnreachableError</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>todo</code>             \u2013              </li> <li> <code>unreachable</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.DispatchLookupError","title":"DispatchLookupError","text":"<pre><code>DispatchLookupError(\n    func: Callable,\n    args: Sequence = (),\n    kwargs: Mapping = {},\n)\n</code></pre> <p>               Bases: <code>LookupError</code></p> <p>Parameters:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            </li> <li> <code>params</code>               (<code>Params</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>func</code>               (<code>Callable</code>)           \u2013            </li> <li> <code>params</code>               (<code>Params</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/error/_dispatch.py</code> <pre><code>def __init__(\n    self, func: Callable, args: Sequence = (), kwargs: Mapping = {}\n) -&gt; None:\n    params = Params(args=args, kwargs=kwargs)\n    self.__attrs_init__(func=func, params=params)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.DispatchLookupError.func","title":"func  <code>instance-attribute</code>","text":"<pre><code>func: Callable\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.DispatchLookupError.params","title":"params  <code>instance-attribute</code>","text":"<pre><code>params: Params\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.DispatchLookupError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_dispatch.py</code> <pre><code>def __str__(self) -&gt; str:\n    from liblaf.grapes import pretty\n\n    pretty_call: str = pretty.pretty_call(\n        self.func, self.params.args, self.params.kwargs\n    )\n    return f\"`{pretty_call}` could not be resolved.\"\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.MatchError","title":"MatchError","text":"<p>               Bases: <code>ValueError</code></p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>Any</code>)           \u2013            </li> <li> <code>typ</code>               (<code>str | type</code>, default:                   <code>'match'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>typ</code>               (<code>str | type</code>)           \u2013            </li> <li> <code>value</code>               (<code>Any</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.MatchError.typ","title":"typ  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>typ: str | type = 'match'\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.MatchError.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Any\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.MatchError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_match.py</code> <pre><code>def __str__(self) -&gt; str:\n    cls: str = self.typ if isinstance(self.typ, str) else self.typ.__qualname__\n    return f\"{self.value!r} is not a valid {cls}.\"\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.TodoError","title":"TodoError","text":"<p>               Bases: <code>NotImplementedError</code></p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str</code>, default:                   <code>'not yet implemented'</code> )           \u2013            </li> <li> <code>assignee</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>assignee</code>               (<code>str | None</code>)           \u2013            </li> <li> <code>message</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.TodoError.assignee","title":"assignee  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>assignee: str | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.TodoError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = 'not yet implemented'\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.TodoError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def __str__(self) -&gt; str:\n    msg: str = \"TODO\"\n    if self.assignee:\n        msg += f\"({self.assignee})\"\n    msg += f\": {self.message}\"\n    return msg\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.UnreachableError","title":"UnreachableError","text":"<p>               Bases: <code>AssertionError</code></p> <p>Parameters:</p> <ul> <li> <code>message</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>message</code>               (<code>str | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.UnreachableError.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.UnreachableError.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def __str__(self) -&gt; str:\n    msg: str = \"internal error: entered unreachable code\"\n    if self.message:\n        msg += f\": {self.message}\"\n    return msg\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.todo","title":"todo","text":"<pre><code>todo(\n    message: str = \"not yet implemented\",\n    assignee: str | None = None,\n) -&gt; Never\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def todo(message: str = \"not yet implemented\", assignee: str | None = None) -&gt; Never:\n    raise TodoError(message=message, assignee=assignee)\n</code></pre>"},{"location":"reference/liblaf/grapes/error/#liblaf.grapes.error.unreachable","title":"unreachable","text":"<pre><code>unreachable(message: str | None = None) -&gt; Never\n</code></pre> Source code in <code>src/liblaf/grapes/error/_misc.py</code> <pre><code>def unreachable(message: str | None = None) -&gt; Never:\n    raise UnreachableError(message=message)\n</code></pre>"},{"location":"reference/liblaf/grapes/functools/","title":"functools","text":""},{"location":"reference/liblaf/grapes/functools/#liblaf.grapes.functools","title":"liblaf.grapes.functools","text":"<p>Classes:</p> <ul> <li> <code>MemorizedFunc</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>cache</code>             \u2013              </li> <li> <code>wrapt_getattr</code>             \u2013              </li> <li> <code>wrapt_setattr</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/functools/#liblaf.grapes.functools.MemorizedFunc","title":"MemorizedFunc","text":"<p>               Bases: <code>Protocol</code></p> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/functools/#liblaf.grapes.functools.MemorizedFunc.__call__","title":"__call__","text":"<pre><code>__call__(*args: P.args, **kwargs: P.kwargs) -&gt; T\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_cache.py</code> <pre><code>def __call__(self, *args: P.args, **kwargs: P.kwargs) -&gt; T: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/functools/#liblaf.grapes.functools.cache","title":"cache","text":"<pre><code>cache(\n    func: Callable[P, T],\n    /,\n    *,\n    memory: Memory | None = ...,\n    ignore: list[str] | None = ...,\n    verbose: int | None = ...,\n    mmap_mode: Literal[\"r+\", \"r\", \"w+\", \"c\"] | None = ...,\n    cache_validation_callback: Callable[[Metadata], bool]\n    | None = ...,\n    bytes_limit: int | str | None = ...,\n    items_limit: int | None = ...,\n    age_limit: timedelta | None = ...,\n) -&gt; MemorizedFunc[P, T]\n</code></pre><pre><code>cache(\n    *,\n    memory: Memory | None = None,\n    ignore: list[str] | None = ...,\n    verbose: int | None = ...,\n    mmap_mode: Literal[\"r+\", \"r\", \"w+\", \"c\"] | None = ...,\n    cache_validation_callback: Callable[[Metadata], bool]\n    | None = ...,\n    bytes_limit: int | str | None = ...,\n    items_limit: int | None = ...,\n    age_limit: timedelta | None = ...,\n) -&gt; Callable[[Callable[P, T]], MemorizedFunc[P, T]]\n</code></pre> <pre><code>cache(\n    func: Callable | None = None, /, **kwargs: Any\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_cache.py</code> <pre><code>def cache(func: Callable | None = None, /, **kwargs: Any) -&gt; Any:\n    if func is None:\n        return functools.partial(cache, **kwargs)\n    memory: joblib.Memory | None = kwargs.pop(\"memory\", None)\n    if memory is None:\n        memory = new_memory()\n    cache_kwargs: dict[str, Any] = _filter_keys(\n        kwargs, (\"ignore\", \"verbose\", \"mmap_mode\", \"cache_validation_callback\")\n    )\n    reduce_size_kwargs: dict[str, Any] = _filter_keys(\n        kwargs, (\"bytes_limit\", \"items_limit\", \"age_limit\")\n    )\n    reduce_size_kwargs.setdefault(\"bytes_limit\", config.joblib.memory.bytes_limit)\n\n    @wrapt.function_wrapper\n    def wrapper[**P, T](\n        wrapped: Callable[P, T], _instance: Any, args: tuple, kwargs: dict[str, Any]\n    ) -&gt; T:\n        result: Any = wrapped(*args, **kwargs)\n        memory.reduce_size(**reduce_size_kwargs)\n        return result\n\n    func = memory.cache(func, **cache_kwargs)\n    func = wrapper(func)\n    wrapt_setattr(func, \"memory\", memory)\n    return func\n</code></pre>"},{"location":"reference/liblaf/grapes/functools/#liblaf.grapes.functools.wrapt_getattr","title":"wrapt_getattr","text":"<pre><code>wrapt_getattr(obj: Any, name: str) -&gt; Any\n</code></pre><pre><code>wrapt_getattr(obj: Any, name: str, default: T) -&gt; Any | T\n</code></pre> <pre><code>wrapt_getattr(\n    obj: Any, name: str, default: Any = MISSING\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_wrapt.py</code> <pre><code>def wrapt_getattr(obj: Any, name: str, default: Any = MISSING, /) -&gt; Any:\n    name = f\"_self_{name}\"\n    try:\n        return getattr(obj, name)\n    except AttributeError:\n        parent: Any = getattr(obj, \"_self_parent\", None)\n        if parent is None:\n            if default is MISSING:\n                raise\n            return default\n        if hasattr(parent, name):\n            return getattr(parent, name)\n        if default is MISSING:\n            raise\n        return default\n</code></pre>"},{"location":"reference/liblaf/grapes/functools/#liblaf.grapes.functools.wrapt_setattr","title":"wrapt_setattr","text":"<pre><code>wrapt_setattr(obj: Any, name: str, value: Any) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/functools/_wrapt.py</code> <pre><code>def wrapt_setattr(obj: Any, name: str, value: Any, /) -&gt; None:\n    name = f\"_self_{name}\"\n    setattr(obj, name, value)\n</code></pre>"},{"location":"reference/liblaf/grapes/git/","title":"git","text":""},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git","title":"liblaf.grapes.git","text":"<p>Classes:</p> <ul> <li> <code>GitInfo</code>           \u2013            <p>\u2026</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>info</code>             \u2013              </li> <li> <code>root</code>             \u2013              </li> <li> <code>root_or_cwd</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo","title":"GitInfo","text":"<p>               Bases: <code>Protocol</code></p> <p>\u2026</p> References <ol> <li>nephila/giturlparse: Parse &amp; rewrite git urls (supports GitHub, Bitbucket, Assembla \u2026)</li> </ol> <p>Attributes:</p> <ul> <li> <code>access_token</code>               (<code>str</code>)           \u2013            <p>access token from <code>&lt;username&gt;:&lt;access_token&gt;@&lt;url&gt;</code> gitlab / github urls</p> </li> <li> <code>branch</code>               (<code>str</code>)           \u2013            <p>branch name (when parseable) - gitlab / github only</p> </li> <li> <code>groups</code>               (<code>list[str]</code>)           \u2013            <p>list of groups - gitlab only</p> </li> <li> <code>host</code>               (<code>str</code>)           \u2013            <p>server hostname</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>same as <code>repo</code></p> </li> <li> <code>owner</code>               (<code>str</code>)           \u2013            <p>repository owner (user or organization)</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>path to file or directory (includes the branch name) - gitlab / github only</p> </li> <li> <code>path_raw</code>               (<code>str</code>)           \u2013            <p>raw path starting from the repo name (might include platform keyword) - gitlab / github only</p> </li> <li> <code>platform</code>               (<code>str</code>)           \u2013            <p>platform codename</p> </li> <li> <code>port</code>               (<code>str</code>)           \u2013            <p>URL port (only if explicitly defined in URL)</p> </li> <li> <code>protocol</code>               (<code>str</code>)           \u2013            <p>URL protocol (git, ssh, http/https)</p> </li> <li> <code>protocols</code>               (<code>list[str]</code>)           \u2013            <p>list of protocols explicitly defined in URL</p> </li> <li> <code>repo</code>               (<code>str</code>)           \u2013            <p>repository name</p> </li> <li> <code>resource</code>               (<code>str</code>)           \u2013            <p>same as <code>host</code></p> </li> <li> <code>user</code>               (<code>str</code>)           \u2013            <p>repository user</p> </li> <li> <code>username</code>               (<code>str</code>)           \u2013            <p>username from <code>&lt;username&gt;:&lt;access_token&gt;@&lt;url&gt;</code> gitlab / github urls</p> </li> </ul>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.access_token","title":"access_token  <code>instance-attribute</code>","text":"<pre><code>access_token: str\n</code></pre> <p>access token from <code>&lt;username&gt;:&lt;access_token&gt;@&lt;url&gt;</code> gitlab / github urls</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.branch","title":"branch  <code>instance-attribute</code>","text":"<pre><code>branch: str\n</code></pre> <p>branch name (when parseable) - gitlab / github only</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.groups","title":"groups  <code>instance-attribute</code>","text":"<pre><code>groups: list[str]\n</code></pre> <p>list of groups - gitlab only</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host: str\n</code></pre> <p>server hostname</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>same as <code>repo</code></p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.owner","title":"owner  <code>instance-attribute</code>","text":"<pre><code>owner: str\n</code></pre> <p>repository owner (user or organization)</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path: str\n</code></pre> <p>path to file or directory (includes the branch name) - gitlab / github only</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.path_raw","title":"path_raw  <code>instance-attribute</code>","text":"<pre><code>path_raw: str\n</code></pre> <p>raw path starting from the repo name (might include platform keyword) - gitlab / github only</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.platform","title":"platform  <code>instance-attribute</code>","text":"<pre><code>platform: str\n</code></pre> <p>platform codename</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: str\n</code></pre> <p>URL port (only if explicitly defined in URL)</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.protocol","title":"protocol  <code>instance-attribute</code>","text":"<pre><code>protocol: str\n</code></pre> <p>URL protocol (git, ssh, http/https)</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.protocols","title":"protocols  <code>instance-attribute</code>","text":"<pre><code>protocols: list[str]\n</code></pre> <p>list of protocols explicitly defined in URL</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.repo","title":"repo  <code>instance-attribute</code>","text":"<pre><code>repo: str\n</code></pre> <p>repository name</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.resource","title":"resource  <code>instance-attribute</code>","text":"<pre><code>resource: str\n</code></pre> <p>same as <code>host</code></p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.user","title":"user  <code>instance-attribute</code>","text":"<pre><code>user: str\n</code></pre> <p>repository user</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.GitInfo.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str\n</code></pre> <p>username from <code>&lt;username&gt;:&lt;access_token&gt;@&lt;url&gt;</code> gitlab / github urls</p>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.info","title":"info","text":"<pre><code>info(\n    path: PathLike | None = None,\n    *,\n    search_parent_directories: bool = True,\n) -&gt; GitInfo\n</code></pre> Source code in <code>src/liblaf/grapes/git/_info.py</code> <pre><code>def info(\n    path: PathLike | None = None, *, search_parent_directories: bool = True\n) -&gt; GitInfo:\n    repo = git.Repo(path=path, search_parent_directories=search_parent_directories)\n    url: str = repo.remote().url\n    return giturlparse.parse(url)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.root","title":"root","text":"<pre><code>root(\n    path: PathLike | None = None,\n    *,\n    search_parent_directories: bool = True,\n) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/grapes/git/_root.py</code> <pre><code>def root(\n    path: PathLike | None = None, *, search_parent_directories: bool = True\n) -&gt; Path:\n    repo = git.Repo(path=path, search_parent_directories=search_parent_directories)\n    return Path(repo.working_dir)\n</code></pre>"},{"location":"reference/liblaf/grapes/git/#liblaf.grapes.git.root_or_cwd","title":"root_or_cwd","text":"<pre><code>root_or_cwd(\n    path: PathLike | None = None,\n    *,\n    search_parent_directories: bool = True,\n) -&gt; Path\n</code></pre> Source code in <code>src/liblaf/grapes/git/_root.py</code> <pre><code>def root_or_cwd(\n    path: PathLike | None = None, *, search_parent_directories: bool = True\n) -&gt; Path:\n    try:\n        return root(path=path, search_parent_directories=search_parent_directories)\n    except git.exc.InvalidGitRepositoryError:\n        return Path()\n</code></pre>"},{"location":"reference/liblaf/grapes/itertools/","title":"itertools","text":""},{"location":"reference/liblaf/grapes/itertools/#liblaf.grapes.itertools","title":"liblaf.grapes.itertools","text":"<p>Functions:</p> <ul> <li> <code>as_iterable</code>             \u2013              <p>.</p> </li> <li> <code>as_sequence</code>             \u2013              <p>.</p> </li> <li> <code>deep_merge</code>             \u2013              </li> <li> <code>first_not_none</code>             \u2013              <p>Returns the first <code>not None</code> value in the <code>args</code>.</p> </li> <li> <code>len_or_none</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/itertools/#liblaf.grapes.itertools.as_iterable","title":"as_iterable","text":"<pre><code>as_iterable(\n    obj: Any, base_type: ClassInfo | None = (str, bytes)\n) -&gt; Iterable\n</code></pre> <p>.</p> <p>Examples:</p> <p>If <code>obj</code> is iterable, return an iterator over its items:</p> <pre><code>&gt;&gt;&gt; obj = (1, 2, 3)\n&gt;&gt;&gt; as_iterable(obj)\n(1, 2, 3)\n</code></pre> <p>If <code>obj</code> is not iterable, return a one-item iterable containing <code>obj</code>:</p> <pre><code>&gt;&gt;&gt; obj = 1\n&gt;&gt;&gt; as_iterable(obj)\n(1,)\n</code></pre> <p>If <code>obj</code> is <code>None</code>, return an empty iterable:</p> <pre><code>&gt;&gt;&gt; obj = None\n&gt;&gt;&gt; as_iterable(None)\n()\n</code></pre> <p>By default, binary and text strings are not considered iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_iterable(obj)\n('foo',)\n</code></pre> <p>If <code>base_type</code> is set, objects for which <code>isinstance(obj, base_type)</code> returns <code>True</code> won\u2019t be considered iterable.</p> <pre><code>&gt;&gt;&gt; obj = {\"a\": 1}\n&gt;&gt;&gt; as_iterable(obj)\n{'a': 1}\n&gt;&gt;&gt; as_iterable(obj, base_type=dict)  # Treat dicts as a unit\n({'a': 1},)\n</code></pre> <p>Set <code>base_type</code> to <code>None</code> to avoid any special handling and treat objects Python considers iterable as iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_iterable(obj, base_type=None)\n'foo'\n</code></pre> References <ol> <li><code>more_itertools.always_iterable</code></li> </ol> Source code in <code>src/liblaf/grapes/itertools/_as_iterable.py</code> <pre><code>def as_iterable(obj: Any, base_type: ClassInfo | None = (str, bytes)) -&gt; Iterable:\n    \"\"\".\n\n    Examples:\n        If `obj` is iterable, return an iterator over its items:\n\n        &gt;&gt;&gt; obj = (1, 2, 3)\n        &gt;&gt;&gt; as_iterable(obj)\n        (1, 2, 3)\n\n        If `obj` is not iterable, return a one-item iterable containing `obj`:\n\n        &gt;&gt;&gt; obj = 1\n        &gt;&gt;&gt; as_iterable(obj)\n        (1,)\n\n        If `obj` is `None`, return an empty iterable:\n\n        &gt;&gt;&gt; obj = None\n        &gt;&gt;&gt; as_iterable(None)\n        ()\n\n        By default, binary and text strings are not considered iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_iterable(obj)\n        ('foo',)\n\n        If `base_type` is set, objects for which `isinstance(obj, base_type)` returns ``True`` won't be considered iterable.\n\n        &gt;&gt;&gt; obj = {\"a\": 1}\n        &gt;&gt;&gt; as_iterable(obj)\n        {'a': 1}\n        &gt;&gt;&gt; as_iterable(obj, base_type=dict)  # Treat dicts as a unit\n        ({'a': 1},)\n\n        Set `base_type` to `None` to avoid any special handling and treat objects Python considers iterable as iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_iterable(obj, base_type=None)\n        'foo'\n\n    References:\n        1. [`more_itertools.always_iterable`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable)\n    \"\"\"\n    if obj is None:\n        return ()\n    if base_type is not None and isinstance(obj, base_type):\n        return (obj,)\n    if isinstance(obj, Iterable):\n        return obj\n    return (obj,)\n</code></pre>"},{"location":"reference/liblaf/grapes/itertools/#liblaf.grapes.itertools.as_sequence","title":"as_sequence","text":"<pre><code>as_sequence(\n    obj: Any, base_type: ClassInfo | None = (str, bytes)\n) -&gt; Sequence\n</code></pre> <p>.</p> <p>Examples:</p> <p>If <code>obj</code> is iterable, return an iterator over its items:</p> <pre><code>&gt;&gt;&gt; obj = (1, 2, 3)\n&gt;&gt;&gt; as_sequence(obj)\n(1, 2, 3)\n</code></pre> <p>If <code>obj</code> is not iterable, return a one-item iterable containing <code>obj</code>:</p> <pre><code>&gt;&gt;&gt; obj = 1\n&gt;&gt;&gt; as_sequence(obj)\n(1,)\n</code></pre> <p>If <code>obj</code> is <code>None</code>, return an empty iterable:</p> <pre><code>&gt;&gt;&gt; obj = None\n&gt;&gt;&gt; as_sequence(None)\n()\n</code></pre> <p>By default, binary and text strings are not considered iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_sequence(obj)\n('foo',)\n</code></pre> <p>If <code>base_type</code> is set, objects for which <code>isinstance(obj, base_type)</code> returns <code>True</code> won\u2019t be considered iterable.</p> <pre><code>&gt;&gt;&gt; obj = {\"a\": 1}\n&gt;&gt;&gt; as_sequence(obj)\n({'a': 1},)\n&gt;&gt;&gt; as_sequence(obj, base_type=dict)  # Treat dicts as a unit\n({'a': 1},)\n</code></pre> <p>Set <code>base_type</code> to <code>None</code> to avoid any special handling and treat objects Python considers iterable as iterable:</p> <pre><code>&gt;&gt;&gt; obj = \"foo\"\n&gt;&gt;&gt; as_sequence(obj, base_type=None)\n'foo'\n</code></pre> References <ol> <li><code>more_itertools.always_iterable</code></li> </ol> Source code in <code>src/liblaf/grapes/itertools/_as_sequence.py</code> <pre><code>def as_sequence(obj: Any, base_type: ClassInfo | None = (str, bytes)) -&gt; Sequence:\n    \"\"\".\n\n    Examples:\n        If `obj` is iterable, return an iterator over its items:\n\n        &gt;&gt;&gt; obj = (1, 2, 3)\n        &gt;&gt;&gt; as_sequence(obj)\n        (1, 2, 3)\n\n        If `obj` is not iterable, return a one-item iterable containing `obj`:\n\n        &gt;&gt;&gt; obj = 1\n        &gt;&gt;&gt; as_sequence(obj)\n        (1,)\n\n        If `obj` is `None`, return an empty iterable:\n\n        &gt;&gt;&gt; obj = None\n        &gt;&gt;&gt; as_sequence(None)\n        ()\n\n        By default, binary and text strings are not considered iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_sequence(obj)\n        ('foo',)\n\n        If `base_type` is set, objects for which `isinstance(obj, base_type)` returns ``True`` won't be considered iterable.\n\n        &gt;&gt;&gt; obj = {\"a\": 1}\n        &gt;&gt;&gt; as_sequence(obj)\n        ({'a': 1},)\n        &gt;&gt;&gt; as_sequence(obj, base_type=dict)  # Treat dicts as a unit\n        ({'a': 1},)\n\n        Set `base_type` to `None` to avoid any special handling and treat objects Python considers iterable as iterable:\n\n        &gt;&gt;&gt; obj = \"foo\"\n        &gt;&gt;&gt; as_sequence(obj, base_type=None)\n        'foo'\n\n    References:\n        1. [`more_itertools.always_iterable`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.always_iterable)\n    \"\"\"\n    if obj is None:\n        return ()\n    if base_type is not None and isinstance(obj, base_type):\n        return (obj,)\n    if isinstance(obj, Sequence):\n        return obj\n    return (obj,)\n</code></pre>"},{"location":"reference/liblaf/grapes/itertools/#liblaf.grapes.itertools.deep_merge","title":"deep_merge","text":"<pre><code>deep_merge(\n    *mappings: Mapping[KT, VT], append_arrays: bool = False\n) -&gt; dict[KT, VT]\n</code></pre> Source code in <code>src/liblaf/grapes/itertools/_deep_merge.py</code> <pre><code>def deep_merge[KT, VT](\n    *mappings: Mapping[KT, VT], append_arrays: bool = False\n) -&gt; dict[KT, VT]:\n    result: dict[KT, VT] = {}\n    for mapping in mappings:\n        for key, value in mapping.items():\n            if key not in result:\n                result[key] = value\n            elif isinstance(result[key], Mapping):\n                result[key] = deep_merge(  # pyright: ignore[reportArgumentType]\n                    result[key],  # pyright: ignore[reportArgumentType]\n                    value,  # pyright: ignore[reportArgumentType]\n                    append_arrays=append_arrays,\n                )\n            elif append_arrays and isinstance(result[key], Sequence):\n                result[key] = [*result[key], *value]  # pyright: ignore[reportArgumentType, reportGeneralTypeIssues]\n    return result\n</code></pre>"},{"location":"reference/liblaf/grapes/itertools/#liblaf.grapes.itertools.first_not_none","title":"first_not_none","text":"<pre><code>first_not_none(*args: T | None) -&gt; T\n</code></pre> <p>Returns the first <code>not None</code> value in the <code>args</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; first_not_none(1, 2)\n1\n&gt;&gt;&gt; first_not_none(None, 1)\n1\n</code></pre> References <ol> <li><code>more_itertools.first_true</code></li> </ol> Source code in <code>src/liblaf/grapes/itertools/_first_not_none.py</code> <pre><code>def first_not_none[T](*args: T | None) -&gt; T:\n    \"\"\"Returns the first `not None` value in the `args`.\n\n    Examples:\n        &gt;&gt;&gt; first_not_none(1, 2)\n        1\n        &gt;&gt;&gt; first_not_none(None, 1)\n        1\n\n    References:\n        1. [`more_itertools.first_true`](https://more-itertools.readthedocs.io/en/stable/api.html#more_itertools.first_true)\n    \"\"\"\n    return next(arg for arg in args if arg is not None)\n</code></pre>"},{"location":"reference/liblaf/grapes/itertools/#liblaf.grapes.itertools.len_or_none","title":"len_or_none","text":"<pre><code>len_or_none(iterable: Iterable) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/itertools/_len_or_none.py</code> <pre><code>def len_or_none(iterable: Iterable) -&gt; int | None:\n    try:\n        return len(iterable)  # pyright: ignore[reportArgumentType]\n    except TypeError:\n        return None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/","title":"logging","text":""},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging","title":"liblaf.grapes.logging","text":"<p>Modules:</p> <ul> <li> <code>filters</code>           \u2013            </li> <li> <code>handlers</code>           \u2013            </li> <li> <code>helpers</code>           \u2013            </li> <li> <code>sink</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>FilterLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>CompositeFilter</code>           \u2013            </li> <li> <code>FilterByName</code>           \u2013            </li> <li> <code>FilterByVersion</code>           \u2013            </li> <li> <code>FilterOnce</code>           \u2013            </li> <li> <code>InterceptHandler</code>           \u2013            <p>Logs to loguru from Python logging module.</p> </li> <li> <code>RichSink</code>           \u2013            </li> <li> <code>RichSinkColumn</code>           \u2013            </li> <li> <code>RichSinkColumnElapsed</code>           \u2013            </li> <li> <code>RichSinkColumnLevel</code>           \u2013            </li> <li> <code>RichSinkColumnLocation</code>           \u2013            </li> <li> <code>RichSinkColumnMessage</code>           \u2013            </li> <li> <code>RichSinkColumnTime</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>add_level</code>             \u2013              </li> <li> <code>as_level_no_dict</code>             \u2013              </li> <li> <code>clear_stdlib_handlers</code>             \u2013              </li> <li> <code>default_columns</code>             \u2013              </li> <li> <code>default_console</code>             \u2013              </li> <li> <code>file_handler</code>             \u2013              </li> <li> <code>get_level_no</code>             \u2013              </li> <li> <code>init</code>             \u2013              </li> <li> <code>new_filter</code>             \u2013              </li> <li> <code>new_format</code>             \u2013              </li> <li> <code>patch_loguru_get_frame</code>             \u2013              </li> <li> <code>rich_handler</code>             \u2013              </li> <li> <code>rich_traceback</code>             \u2013              </li> <li> <code>setup_excepthook</code>             \u2013              </li> <li> <code>setup_icecream</code>             \u2013              </li> <li> <code>setup_loguru_intercept</code>             \u2013              <p>Logs to loguru from Python logging module.</p> </li> <li> <code>setup_unraisablehook</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>helper</code>               (<code>DepthTracker</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.helper","title":"helper  <code>module-attribute</code>","text":"<pre><code>helper: DepthTracker = DepthTracker()\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterLike","title":"FilterLike","text":"<pre><code>FilterLike = str | FilterDict | FilterFunction | None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter","title":"CompositeFilter","text":"<pre><code>CompositeFilter(by_name: FilterDict | None = None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by_name</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>by_version</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>level</code>               (<code>str</code>, default:                   <code>'INFO'</code> )           \u2013            </li> <li> <code>once</code>               (<code>str</code>, default:                   <code>FilterOnce(_history=set())</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>get_level</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>by_name</code>               (<code>FilterByName</code>)           \u2013            </li> <li> <code>by_version</code>               (<code>FilterByVersion</code>)           \u2013            </li> <li> <code>level</code>               (<code>int</code>)           \u2013            </li> <li> <code>once</code>               (<code>FilterOnce</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/logging/filters/_composite.py</code> <pre><code>def __init__(self, by_name: loguru.FilterDict | None = None) -&gt; None:\n    if by_name is None:\n        by_name = {\"__main__\": \"TRACE\"}\n    level: bool | int | str = by_name.get(\"\", \"INFO\")\n    self.__attrs_init__(by_name=FilterByName(by_name), level=level)  # pyright: ignore[reportAttributeAccessIssue, reportArgumentType]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter.by_name","title":"by_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>by_name: FilterByName = field(factory=FilterByName)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter.by_version","title":"by_version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>by_version: FilterByVersion = field(factory=FilterByVersion)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: int = field(default='INFO', converter=get_level_no)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter.once","title":"once  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>once: FilterOnce = field(factory=FilterOnce)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_composite.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    if record is self._cache_key:\n        return self._cache_value\n    result: bool = self._filter(record)\n    self._cache_key = record\n    self._cache_value = result\n    return result\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.CompositeFilter.get_level","title":"get_level","text":"<pre><code>get_level(name: str | None) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_composite.py</code> <pre><code>def get_level(self, name: str | None) -&gt; int | None:\n    level: int | None = self.by_name.get_level(name)\n    if level is not None:\n        return level\n    level = self.by_version.get_level(name)\n    if level is not None:\n        return level\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByName","title":"FilterByName","text":"<p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>get_level</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByName.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_name.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    level: int | None = self.get_level(record[\"name\"])\n    if level is None:\n        return True\n    return record[\"level\"].no &gt;= level\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByName.get_level","title":"get_level","text":"<pre><code>get_level(name: str | None) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_name.py</code> <pre><code>def get_level(self, name: str | None) -&gt; int | None:\n    while True:\n        if not name:\n            return None\n        level: int | None = self._levels.get(name)\n        if level is not None:\n            return level\n        name = get_parent(name)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByVersion","title":"FilterByVersion","text":"<p>Parameters:</p> <ul> <li> <code>level_dev</code>               (<code>str</code>, default:                   <code>'TRACE'</code> )           \u2013            </li> <li> <code>level_prerelease</code>               (<code>str</code>, default:                   <code>'DEBUG'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>get_level</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>level_dev</code>               (<code>int</code>)           \u2013            </li> <li> <code>level_prerelease</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByVersion.level_dev","title":"level_dev  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_dev: int = field(\n    default=\"TRACE\", converter=get_level_no\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByVersion.level_prerelease","title":"level_prerelease  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_prerelease: int = field(\n    default=\"DEBUG\", converter=get_level_no\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByVersion.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_version.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    level: int | None = self.get_level(record[\"name\"])\n    if level is None:\n        return True\n    return record[\"level\"].no &gt;= level\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterByVersion.get_level","title":"get_level","text":"<pre><code>get_level(name: str | None) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_version.py</code> <pre><code>def get_level(self, name: str | None) -&gt; int | None:\n    version: packaging.version.Version | None = self._get_version(name)\n    if version is None:\n        return None\n    if version.is_devrelease:\n        return self.level_dev\n    if version.is_prerelease:\n        return self.level_prerelease\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterOnce","title":"FilterOnce","text":"<p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.FilterOnce.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_once.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    if not record[\"extra\"].get(\"once\", False):\n        return True\n    record_hash: Hashable = self._hash_record(record)\n    if record_hash in self._history:\n        return False\n    self._history.add(record_hash)\n    return True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.InterceptHandler","title":"InterceptHandler","text":"<p>               Bases: <code>Handler</code></p> <p>Logs to loguru from Python logging module.</p> References <ol> <li>Entirely compatible with standard logging</li> <li>loguru-logging-intercept/loguru_logging_intercept.py at f358b75ef4162ea903bf7a3298c22b1be83110da \u00b7 MatthewScholefield/loguru-logging-intercept</li> </ol> <p>Methods:</p> <ul> <li> <code>emit</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.InterceptHandler.emit","title":"emit","text":"<pre><code>emit(record: LogRecord) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_std_intercept.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    if logger is None:  # logger has been cleaned up\n        return\n\n    # Get corresponding Loguru level if it exists.\n    level: str | int\n    try:\n        level = logger.level(record.levelname).name\n    except ValueError:\n        level = record.levelno\n\n    # Find caller from where originated the logged message.\n    frame: types.FrameType | None = inspect.currentframe()\n    depth: int = 0\n    while frame and (depth == 0 or frame.f_code.co_filename == logging.__file__):\n        frame = frame.f_back\n        depth += 1\n\n    logger.opt(depth=depth, exception=record.exc_info).log(\n        level, record.getMessage()\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSink","title":"RichSink","text":"<pre><code>RichSink(\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>columns</code>               (<code>Sequence[RichSinkColumn]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>console</code>               (<code>Console</code>, default:                   <code>&lt;console width=128 None&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>render_exception</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>columns</code>               (<code>Sequence[RichSinkColumn]</code>)           \u2013            </li> <li> <code>console</code>               (<code>Console</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def __init__(\n    self,\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n) -&gt; None:\n    if columns is None:\n        columns = default_columns(enable_link=enable_link)\n    self.__attrs_init__(columns=columns, console=console)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSink.columns","title":"columns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>columns: Sequence[RichSinkColumn] = field(\n    converter=default_if_none(factory=default_columns),\n    factory=default_columns,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSink.console","title":"console  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>console: Console = field(\n    converter=default_if_none(factory=default_console),\n    factory=default_console,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSink.__call__","title":"__call__","text":"<pre><code>__call__(message: Message) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def __call__(self, message: \"loguru.Message\", /) -&gt; None:\n    record: loguru.Record = message.record\n    # TODO: `console.print()` is slow\n    self.console.print(\n        *self.render(record), overflow=\"ignore\", no_wrap=True, crop=False\n    )\n    if (excpetion := self.render_exception(record)) is not None:\n        self.console.print(excpetion)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSink.render","title":"render","text":"<pre><code>render(record: Record) -&gt; Generator[RenderableType]\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def render(self, record: \"loguru.Record\", /) -&gt; Generator[RenderableType]:\n    for column in self.columns:\n        yield column.render(record)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSink.render_exception","title":"render_exception","text":"<pre><code>render_exception(record: Record) -&gt; RenderableType | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def render_exception(self, record: \"loguru.Record\", /) -&gt; RenderableType | None:\n    exception: loguru.RecordException | None = record[\"exception\"]\n    if exception is None:\n        return None\n    exc_type: type[BaseException] | None\n    exc_value: BaseException | None\n    traceback: types.TracebackType | None\n    exc_type, exc_value, traceback = exception\n    if exc_type is None or exc_value is None:\n        return None\n    return rich_traceback(exc_type, exc_value, traceback)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumn","title":"RichSinkColumn","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumn.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_abc.py</code> <pre><code>@abc.abstractmethod\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnElapsed","title":"RichSinkColumnElapsed","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnElapsed.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_elapsed.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    elapsed: datetime.timedelta = record[\"elapsed\"]\n    hh: int\n    mm: int\n    ss: int\n    mm, ss = divmod(int(elapsed.total_seconds()), 60)\n    hh, mm = divmod(mm, 60)\n    # TODO: handle longer timedelta\n    # ref: &lt;https://docs.pydantic.dev/latest/api/standard_library_types/#datetimetimedelta&gt;\n    # format: [[DD]D,]HH:MM:SS[.ffffff]\n    # Ex: '1d,01:02:03.000004' or '1D01:02:03.000004' or '01:02:03'\n    return Text(\n        f\"{hh:02d}:{mm:02d}:{ss:02d}.{elapsed.microseconds:06d}\", style=\"log.time\"\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLevel","title":"RichSinkColumnLevel","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLevel.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int = 1\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLevel.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_level.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    level: str = record[\"level\"].name\n    return Text(f\"{level:&lt;.{self.width}}\", style=f\"logging.level.{level.lower()}\")\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLocation","title":"RichSinkColumnLocation","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>abbr_name</code>               (<code>str</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>enable_link</code>               (<code>str</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>width</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> <li> <code>render_name</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>abbr_name</code>               (<code>bool</code>)           \u2013            </li> <li> <code>enable_link</code>               (<code>bool</code>)           \u2013            </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLocation.abbr_name","title":"abbr_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>abbr_name: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLocation.enable_link","title":"enable_link  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_link: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLocation.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLocation.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_location.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: loguru.Record, /) -&gt; RenderableType:\n    name: str | None = self.render_name(record)\n    location: Text = pretty.rich_location(\n        name=name,\n        function=record[\"function\"],\n        line=record[\"line\"],\n        file=record[\"file\"].path,\n        enable_link=self.enable_link,\n        width=self.width,\n    )\n    location.style = \"log.path\"\n    return location\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnLocation.render_name","title":"render_name","text":"<pre><code>render_name(record: Record) -&gt; str | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_location.py</code> <pre><code>def render_name(self, record: loguru.Record) -&gt; str | None:\n    name: str | None = record[\"name\"]\n    if name is None:\n        return None\n    if not self.abbr_name:\n        return name\n    function: str = record[\"function\"]\n    start: int = 0\n    while True:\n        index: int = name.find(\".\", start)\n        if index &lt; 0:\n            return name\n        module_name: str = name[:index]\n        module: types.ModuleType | None = sys.modules.get(module_name)\n        if module is None:\n            return name\n        if hasattr(module, function):\n            return module_name\n        start = index + 1\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnMessage","title":"RichSinkColumnMessage","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>highlighter</code>               (<code>Highlighter</code>, default:                   <code>&lt;rich.highlighter.ReprHighlighter object at 0x7f690bf39090&gt;</code> )           \u2013            <p>Highlights the text typically produced from <code>__repr__</code> methods.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>highlighter</code>               (<code>Highlighter</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnMessage.highlighter","title":"highlighter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlighter: Highlighter = field(factory=ReprHighlighter)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnMessage.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_message.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\") -&gt; RenderableType:\n    if (rich := record[\"extra\"].get(\"rich\")) is not None:\n        return rich\n    message: RenderableType = record[\"message\"].strip()\n    if \"\\x1b\" in message:\n        return Text.from_ansi(message)\n    if record[\"extra\"].get(\"markup\", True):\n        message = Text.from_markup(message)\n    if highlighter := record[\"extra\"].get(\"highlighter\", self.highlighter):\n        message = highlighter(message)\n    return message\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnTime","title":"RichSinkColumnTime","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'%Y-%m-%dT%H:%M:%S.%f'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>fmt</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnTime.fmt","title":"fmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmt: str = '%Y-%m-%dT%H:%M:%S.%f'\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.RichSinkColumnTime.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_time.py</code> <pre><code>def render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    time: datetime.datetime = record[\"time\"]\n    return Text(f\"{time:{self.fmt}}\", style=\"log.time\")\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.add_level","title":"add_level","text":"<pre><code>add_level(\n    name: str,\n    no: int | None = None,\n    color: str | None = None,\n    icon: str | None = None,\n) -&gt; Level\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_add_level.py</code> <pre><code>def add_level(\n    name: str, no: int | None = None, color: str | None = None, icon: str | None = None\n) -&gt; \"loguru.Level\":\n    core: loguru._logger.Core = logger._core  # pyright: ignore[reportAttributeAccessIssue] # noqa: SLF001\n    if name in core.levels and no == logger.level(name).no:\n        no = None  # skip update severity no\n    return logger.level(name=name, no=no, color=color, icon=icon)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.as_level_no_dict","title":"as_level_no_dict","text":"<pre><code>as_level_no_dict(\n    levels: FilterDict,\n) -&gt; dict[str | None, int]\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_utils.py</code> <pre><code>def as_level_no_dict(levels: loguru.FilterDict) -&gt; dict[str | None, int]:\n    return {key: get_level_no(value) for key, value in levels.items()}\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.clear_stdlib_handlers","title":"clear_stdlib_handlers","text":"<pre><code>clear_stdlib_handlers() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_std_intercept.py</code> <pre><code>def clear_stdlib_handlers() -&gt; None:\n    for std_logger in logging.root.manager.loggerDict.values():\n        if isinstance(std_logger, logging.PlaceHolder):\n            continue\n        std_logger.handlers.clear()\n        std_logger.propagate = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.default_columns","title":"default_columns","text":"<pre><code>default_columns(\n    *, enable_link: bool = True\n) -&gt; Sequence[RichSinkColumn]\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def default_columns(*, enable_link: bool = True) -&gt; Sequence[RichSinkColumn]:\n    return [\n        RichSinkColumnElapsed(),\n        RichSinkColumnLevel(),\n        RichSinkColumnLocation(enable_link=enable_link),\n        RichSinkColumnMessage(),\n    ]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.default_console","title":"default_console","text":"<pre><code>default_console() -&gt; Console\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def default_console() -&gt; Console:\n    return pretty.get_console(stderr=True)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.file_handler","title":"file_handler","text":"<pre><code>file_handler(\n    **kwargs: Unpack[FileHandlerConfig],\n) -&gt; FileHandlerConfig\n</code></pre> Source code in <code>src/liblaf/grapes/logging/handlers/_file.py</code> <pre><code>def file_handler(\n    **kwargs: Unpack[\"loguru.FileHandlerConfig\"],\n) -&gt; \"loguru.FileHandlerConfig\":\n    if \"sink\" not in kwargs:\n        kwargs[\"sink\"] = config.logging.file or Path(\"run.log\")\n    if \"format\" not in kwargs:\n        kwargs[\"format\"] = new_format()\n    kwargs[\"filter\"] = new_filter(kwargs.get(\"filter\"))\n    kwargs.setdefault(\"mode\", \"w\")\n    return kwargs\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.get_level_no","title":"get_level_no","text":"<pre><code>get_level_no(level: bool | int | str) -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_utils.py</code> <pre><code>def get_level_no(level: bool | int | str) -&gt; int:  # noqa: FBT001\n    if level is True:\n        return 0\n    if level is False:\n        return 100\n    if isinstance(level, int):\n        return level\n    return logger.level(level).no\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.init","title":"init","text":"<pre><code>init(\n    *,\n    enable_link: bool = True,\n    file: PathLike | None = None,\n    filter: FilterLike = None,\n    handlers: Sequence[HandlerConfig] | None = None,\n    intercept: bool = True,\n    level: int | str | None = None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/_init.py</code> <pre><code>def init(\n    *,\n    enable_link: bool = True,\n    file: PathLike | None = None,\n    filter: FilterLike = None,  # noqa: A002\n    handlers: Sequence[\"loguru.HandlerConfig\"] | None = None,\n    intercept: bool = True,\n    level: int | str | None = None,\n) -&gt; None:\n    if file is None:\n        file = config.logging.file\n    if level is None:\n        level = config.logging.level\n\n    if handlers is None:\n        handler_config: Mapping[str, Any] = toolz.valfilter(\n            lambda v: v is not None, {\"filter\": filter, \"level\": level}\n        )\n        handlers: list[loguru.HandlerConfig] = [\n            rich_handler(**handler_config, enable_link=enable_link)\n        ]\n        if file:\n            handlers.append(file_handler(sink=file, **handler_config))\n\n    patch_loguru_get_frame()\n    logger.configure(handlers=handlers)\n    setup_excepthook()\n    setup_icecream()\n    setup_unraisablehook()\n    if intercept:\n        setup_loguru_intercept(level=level)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.new_filter","title":"new_filter","text":"<pre><code>new_filter(f: FilterLike | None = None) -&gt; FilterLike\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_factory.py</code> <pre><code>def new_filter(f: FilterLike | None = None, /) -&gt; FilterLike:\n    if f is None:\n        return CompositeFilter()\n    if isinstance(f, Mapping):\n        return CompositeFilter(f)  # pyright: ignore[reportArgumentType]\n    return f\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.new_format","title":"new_format","text":"<pre><code>new_format(\n    template: str = DEFAULT_FORMAT,\n) -&gt; FormatFunction\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_format.py</code> <pre><code>def new_format(template: str = DEFAULT_FORMAT) -&gt; \"loguru.FormatFunction\":\n    template = template.strip() + \"\\n\"\n\n    def format_(record: \"loguru.Record\", /) -&gt; str:\n        if record[\"exception\"] is None:\n            return template\n        exc_type: type[BaseException] | None\n        exc_value: BaseException | None\n        traceback: types.TracebackType | None\n        exc_type, exc_value, traceback = record[\"exception\"]\n        if exc_type is None or exc_value is None:\n            return template + \"{exception}\\n\"\n        console: Console = pretty.get_console(color_system=None)\n        rich_tb: Traceback = rich_traceback(exc_type, exc_value, traceback, width=128)\n        with console.capture() as capture:\n            console.print(rich_tb)\n        record[\"extra\"][\"rich_traceback\"] = capture.get()\n        return template + \"{extra[rich_traceback]}\\n\"\n\n    return format_\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.patch_loguru_get_frame","title":"patch_loguru_get_frame","text":"<pre><code>patch_loguru_get_frame(\n    new: Callable[[int], FrameType | None] = _get_frame,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_get_frame.py</code> <pre><code>def patch_loguru_get_frame(\n    new: Callable[[int], types.FrameType | None] = _get_frame,\n) -&gt; None:\n    # ! dirty hack\n    patcher = unittest.mock.patch(\"loguru._logger.get_frame\", new)\n    patcher.start()\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.rich_handler","title":"rich_handler","text":"<pre><code>rich_handler(\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n    **kwargs: Unpack[BasicHandlerConfig],\n) -&gt; BasicHandlerConfig\n</code></pre> Source code in <code>src/liblaf/grapes/logging/handlers/_rich.py</code> <pre><code>def rich_handler(\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n    **kwargs: Unpack[\"loguru.BasicHandlerConfig\"],\n) -&gt; \"loguru.BasicHandlerConfig\":\n    kwargs[\"sink\"] = RichSink(console=console, columns=columns, enable_link=enable_link)\n    kwargs[\"format\"] = \"\"\n    kwargs[\"filter\"] = new_filter(kwargs.get(\"filter\"))\n    return kwargs\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.rich_traceback","title":"rich_traceback","text":"<pre><code>rich_traceback(\n    exc_type: type[BaseException],\n    exc_value: BaseException,\n    traceback: TracebackType | None,\n    /,\n    **kwargs: Unpack[TracebackOptions],\n) -&gt; Traceback\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_traceback.py</code> <pre><code>def rich_traceback(\n    exc_type: type[BaseException],\n    exc_value: BaseException,\n    traceback: types.TracebackType | None,\n    /,\n    **kwargs: Unpack[TracebackOptions],\n) -&gt; Traceback:\n    kwargs = toolz.merge(config.traceback.model_dump(), kwargs)\n    kwargs = cast(\"TracebackOptions\", kwargs)\n    if kwargs.get(\"width\") is None:\n        kwargs[\"width\"] = pretty.get_console(stderr=True).width\n    if suppress := kwargs.get(\"suppress\"):\n        kwargs[\"suppress\"] = _validate_suppress(suppress)\n    traceback = _filter_traceback(traceback)\n    # ? dirty hack to avoid long `repr()` output\n    # ref: &lt;https://github.com/Textualize/rich/discussions/3774&gt;\n    with unittest.mock.patch(\"rich.pretty.repr\", new=pretty.pformat):\n        rich_tb: Traceback = Traceback.from_exception(\n            exc_type, exc_value, traceback, **kwargs\n        )\n    # ? dirty hack to support ANSI in exception messages\n    for stack in rich_tb.trace.stacks:\n        if pretty.has_ansi(stack.exc_value):\n            stack.exc_value = Text.from_ansi(stack.exc_value)  # pyright: ignore[reportAttributeAccessIssue]\n    return rich_tb\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.setup_excepthook","title":"setup_excepthook","text":"<pre><code>setup_excepthook(level: int | str = 'CRITICAL') -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_excepthook.py</code> <pre><code>def setup_excepthook(level: int | str = \"CRITICAL\") -&gt; None:\n    def excepthook(\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: types.TracebackType | None,\n        /,\n    ) -&gt; None:\n        logger.opt(exception=(exc_type, exc_value, exc_traceback)).patch(_patcher).log(\n            level, exc_value\n        )\n\n    sys.excepthook = excepthook\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.setup_icecream","title":"setup_icecream","text":"<pre><code>setup_icecream(prefix: str = '') -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_icecream.py</code> <pre><code>def setup_icecream(prefix: str = \"\") -&gt; None:\n    try:\n        from icecream import ic\n    except ImportError:\n        return\n\n    add_level(name=\"ICECREAM\", no=15, color=\"&lt;magenta&gt;&lt;bold&gt;\", icon=\"\ud83c\udf66\")\n\n    def output_function(s: str) -&gt; None:\n        logger.opt(depth=2).log(\"ICECREAM\", s)\n\n    ic.configureOutput(\n        prefix=prefix,\n        argToStringFunction=pretty.pformat,\n        outputFunction=output_function,\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.setup_loguru_intercept","title":"setup_loguru_intercept","text":"<pre><code>setup_loguru_intercept(\n    level: int | str = NOTSET, modules: Iterable[str] = ()\n) -&gt; None\n</code></pre> <p>Logs to loguru from Python logging module.</p> References <ol> <li>Entirely compatible with standard logging</li> <li>loguru-logging-intercept/loguru_logging_intercept.py at f358b75ef4162ea903bf7a3298c22b1be83110da \u00b7 MatthewScholefield/loguru-logging-intercept</li> </ol> Source code in <code>src/liblaf/grapes/logging/helpers/_std_intercept.py</code> <pre><code>def setup_loguru_intercept(\n    level: int | str = logging.NOTSET, modules: Iterable[str] = ()\n) -&gt; None:\n    \"\"\"Logs to loguru from Python logging module.\n\n    References:\n        1. [Entirely compatible with standard logging](https://loguru.readthedocs.io/en/stable/overview.html#entirely-compatible-with-standard-logging)\n        2. [loguru-logging-intercept/loguru_logging_intercept.py at f358b75ef4162ea903bf7a3298c22b1be83110da \u00b7 MatthewScholefield/loguru-logging-intercept](https://github.com/MatthewScholefield/loguru-logging-intercept/blob/f358b75ef4162ea903bf7a3298c22b1be83110da/loguru_logging_intercept.py)\n    \"\"\"\n    core: loguru._logger.Core = logger._core  # pyright: ignore[reportAttributeAccessIssue] # noqa: SLF001\n    for loguru_level in core.levels.values():\n        logging.addLevelName(loguru_level.no, loguru_level.name)\n    if isinstance(level, str):\n        level = logger.level(level).no\n    logging.basicConfig(handlers=[InterceptHandler()], level=level)\n    clear_stdlib_handlers()\n    for logger_name in itertools.chain((\"\",), modules):\n        mod_logger: logging.Logger = logging.getLogger(logger_name)\n        mod_logger.handlers = [InterceptHandler()]\n        mod_logger.propagate = False\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/#liblaf.grapes.logging.setup_unraisablehook","title":"setup_unraisablehook","text":"<pre><code>setup_unraisablehook(level: int | str = 'ERROR') -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_unraisablehook.py</code> <pre><code>def setup_unraisablehook(level: int | str = \"ERROR\") -&gt; None:\n    def unraisablehook(args: \"sys.UnraisableHookArgs\", /) -&gt; None:\n        if logger is None:  # logger has been cleaned up\n            return\n        logger.opt(exception=(args.exc_type, args.exc_value, args.exc_traceback)).log(\n            level,\n            \"{err_msg}: {object!r}\",\n            err_msg=args.err_msg or \"Exception ignored in\",\n            object=args.object,\n        )\n\n    sys.unraisablehook = unraisablehook\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/","title":"filters","text":""},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters","title":"liblaf.grapes.logging.filters","text":"<p>Modules:</p> <ul> <li> <code>typing</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>FilterLike</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>CompositeFilter</code>           \u2013            </li> <li> <code>FilterByName</code>           \u2013            </li> <li> <code>FilterByVersion</code>           \u2013            </li> <li> <code>FilterOnce</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_level_no_dict</code>             \u2013              </li> <li> <code>get_level_no</code>             \u2013              </li> <li> <code>get_parent</code>             \u2013              </li> <li> <code>new_filter</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterLike","title":"FilterLike","text":"<pre><code>FilterLike = str | FilterDict | FilterFunction | None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter","title":"CompositeFilter","text":"<pre><code>CompositeFilter(by_name: FilterDict | None = None)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>by_name</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>by_version</code>               (<code>str</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>level</code>               (<code>str</code>, default:                   <code>'INFO'</code> )           \u2013            </li> <li> <code>once</code>               (<code>str</code>, default:                   <code>FilterOnce(_history=set())</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>get_level</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>by_name</code>               (<code>FilterByName</code>)           \u2013            </li> <li> <code>by_version</code>               (<code>FilterByVersion</code>)           \u2013            </li> <li> <code>level</code>               (<code>int</code>)           \u2013            </li> <li> <code>once</code>               (<code>FilterOnce</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/logging/filters/_composite.py</code> <pre><code>def __init__(self, by_name: loguru.FilterDict | None = None) -&gt; None:\n    if by_name is None:\n        by_name = {\"__main__\": \"TRACE\"}\n    level: bool | int | str = by_name.get(\"\", \"INFO\")\n    self.__attrs_init__(by_name=FilterByName(by_name), level=level)  # pyright: ignore[reportAttributeAccessIssue, reportArgumentType]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter.by_name","title":"by_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>by_name: FilterByName = field(factory=FilterByName)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter.by_version","title":"by_version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>by_version: FilterByVersion = field(factory=FilterByVersion)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter.level","title":"level  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level: int = field(default='INFO', converter=get_level_no)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter.once","title":"once  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>once: FilterOnce = field(factory=FilterOnce)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_composite.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    if record is self._cache_key:\n        return self._cache_value\n    result: bool = self._filter(record)\n    self._cache_key = record\n    self._cache_value = result\n    return result\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.CompositeFilter.get_level","title":"get_level","text":"<pre><code>get_level(name: str | None) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_composite.py</code> <pre><code>def get_level(self, name: str | None) -&gt; int | None:\n    level: int | None = self.by_name.get_level(name)\n    if level is not None:\n        return level\n    level = self.by_version.get_level(name)\n    if level is not None:\n        return level\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByName","title":"FilterByName","text":"<p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>get_level</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByName.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_name.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    level: int | None = self.get_level(record[\"name\"])\n    if level is None:\n        return True\n    return record[\"level\"].no &gt;= level\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByName.get_level","title":"get_level","text":"<pre><code>get_level(name: str | None) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_name.py</code> <pre><code>def get_level(self, name: str | None) -&gt; int | None:\n    while True:\n        if not name:\n            return None\n        level: int | None = self._levels.get(name)\n        if level is not None:\n            return level\n        name = get_parent(name)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByVersion","title":"FilterByVersion","text":"<p>Parameters:</p> <ul> <li> <code>level_dev</code>               (<code>str</code>, default:                   <code>'TRACE'</code> )           \u2013            </li> <li> <code>level_prerelease</code>               (<code>str</code>, default:                   <code>'DEBUG'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>get_level</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>level_dev</code>               (<code>int</code>)           \u2013            </li> <li> <code>level_prerelease</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByVersion.level_dev","title":"level_dev  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_dev: int = field(\n    default=\"TRACE\", converter=get_level_no\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByVersion.level_prerelease","title":"level_prerelease  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>level_prerelease: int = field(\n    default=\"DEBUG\", converter=get_level_no\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByVersion.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_version.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    level: int | None = self.get_level(record[\"name\"])\n    if level is None:\n        return True\n    return record[\"level\"].no &gt;= level\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterByVersion.get_level","title":"get_level","text":"<pre><code>get_level(name: str | None) -&gt; int | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_by_version.py</code> <pre><code>def get_level(self, name: str | None) -&gt; int | None:\n    version: packaging.version.Version | None = self._get_version(name)\n    if version is None:\n        return None\n    if version.is_devrelease:\n        return self.level_dev\n    if version.is_prerelease:\n        return self.level_prerelease\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterOnce","title":"FilterOnce","text":"<p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.FilterOnce.__call__","title":"__call__","text":"<pre><code>__call__(record: Record) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_once.py</code> <pre><code>def __call__(self, record: loguru.Record) -&gt; bool:\n    if not record[\"extra\"].get(\"once\", False):\n        return True\n    record_hash: Hashable = self._hash_record(record)\n    if record_hash in self._history:\n        return False\n    self._history.add(record_hash)\n    return True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.as_level_no_dict","title":"as_level_no_dict","text":"<pre><code>as_level_no_dict(\n    levels: FilterDict,\n) -&gt; dict[str | None, int]\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_utils.py</code> <pre><code>def as_level_no_dict(levels: loguru.FilterDict) -&gt; dict[str | None, int]:\n    return {key: get_level_no(value) for key, value in levels.items()}\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.get_level_no","title":"get_level_no","text":"<pre><code>get_level_no(level: bool | int | str) -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_utils.py</code> <pre><code>def get_level_no(level: bool | int | str) -&gt; int:  # noqa: FBT001\n    if level is True:\n        return 0\n    if level is False:\n        return 100\n    if isinstance(level, int):\n        return level\n    return logger.level(level).no\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.get_parent","title":"get_parent","text":"<pre><code>get_parent(name: str) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_utils.py</code> <pre><code>def get_parent(name: str) -&gt; str:\n    index: int = name.rfind(\".\")\n    return \"\" if index &lt; 0 else name[:index]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/#liblaf.grapes.logging.filters.new_filter","title":"new_filter","text":"<pre><code>new_filter(f: FilterLike | None = None) -&gt; FilterLike\n</code></pre> Source code in <code>src/liblaf/grapes/logging/filters/_factory.py</code> <pre><code>def new_filter(f: FilterLike | None = None, /) -&gt; FilterLike:\n    if f is None:\n        return CompositeFilter()\n    if isinstance(f, Mapping):\n        return CompositeFilter(f)  # pyright: ignore[reportArgumentType]\n    return f\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/filters/typing/","title":"typing","text":""},{"location":"reference/liblaf/grapes/logging/filters/typing/#liblaf.grapes.logging.filters.typing","title":"liblaf.grapes.logging.filters.typing","text":"<p>Type Aliases:</p> <ul> <li> <code>FilterLike</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/filters/typing/#liblaf.grapes.logging.filters.typing.FilterLike","title":"FilterLike","text":"<pre><code>FilterLike = str | FilterDict | FilterFunction | None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/handlers/","title":"handlers","text":""},{"location":"reference/liblaf/grapes/logging/handlers/#liblaf.grapes.logging.handlers","title":"liblaf.grapes.logging.handlers","text":"<p>Functions:</p> <ul> <li> <code>file_handler</code>             \u2013              </li> <li> <code>rich_handler</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/handlers/#liblaf.grapes.logging.handlers.file_handler","title":"file_handler","text":"<pre><code>file_handler(\n    **kwargs: Unpack[FileHandlerConfig],\n) -&gt; FileHandlerConfig\n</code></pre> Source code in <code>src/liblaf/grapes/logging/handlers/_file.py</code> <pre><code>def file_handler(\n    **kwargs: Unpack[\"loguru.FileHandlerConfig\"],\n) -&gt; \"loguru.FileHandlerConfig\":\n    if \"sink\" not in kwargs:\n        kwargs[\"sink\"] = config.logging.file or Path(\"run.log\")\n    if \"format\" not in kwargs:\n        kwargs[\"format\"] = new_format()\n    kwargs[\"filter\"] = new_filter(kwargs.get(\"filter\"))\n    kwargs.setdefault(\"mode\", \"w\")\n    return kwargs\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/handlers/#liblaf.grapes.logging.handlers.rich_handler","title":"rich_handler","text":"<pre><code>rich_handler(\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n    **kwargs: Unpack[BasicHandlerConfig],\n) -&gt; BasicHandlerConfig\n</code></pre> Source code in <code>src/liblaf/grapes/logging/handlers/_rich.py</code> <pre><code>def rich_handler(\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n    **kwargs: Unpack[\"loguru.BasicHandlerConfig\"],\n) -&gt; \"loguru.BasicHandlerConfig\":\n    kwargs[\"sink\"] = RichSink(console=console, columns=columns, enable_link=enable_link)\n    kwargs[\"format\"] = \"\"\n    kwargs[\"filter\"] = new_filter(kwargs.get(\"filter\"))\n    return kwargs\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/","title":"helpers","text":""},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers","title":"liblaf.grapes.logging.helpers","text":"<p>Classes:</p> <ul> <li> <code>InterceptHandler</code>           \u2013            <p>Logs to loguru from Python logging module.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>add_level</code>             \u2013              </li> <li> <code>clear_stdlib_handlers</code>             \u2013              </li> <li> <code>new_format</code>             \u2013              </li> <li> <code>patch_loguru_get_frame</code>             \u2013              </li> <li> <code>rich_traceback</code>             \u2013              </li> <li> <code>setup_excepthook</code>             \u2013              </li> <li> <code>setup_icecream</code>             \u2013              </li> <li> <code>setup_loguru_intercept</code>             \u2013              <p>Logs to loguru from Python logging module.</p> </li> <li> <code>setup_unraisablehook</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.InterceptHandler","title":"InterceptHandler","text":"<p>               Bases: <code>Handler</code></p> <p>Logs to loguru from Python logging module.</p> References <ol> <li>Entirely compatible with standard logging</li> <li>loguru-logging-intercept/loguru_logging_intercept.py at f358b75ef4162ea903bf7a3298c22b1be83110da \u00b7 MatthewScholefield/loguru-logging-intercept</li> </ol> <p>Methods:</p> <ul> <li> <code>emit</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.InterceptHandler.emit","title":"emit","text":"<pre><code>emit(record: LogRecord) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_std_intercept.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    if logger is None:  # logger has been cleaned up\n        return\n\n    # Get corresponding Loguru level if it exists.\n    level: str | int\n    try:\n        level = logger.level(record.levelname).name\n    except ValueError:\n        level = record.levelno\n\n    # Find caller from where originated the logged message.\n    frame: types.FrameType | None = inspect.currentframe()\n    depth: int = 0\n    while frame and (depth == 0 or frame.f_code.co_filename == logging.__file__):\n        frame = frame.f_back\n        depth += 1\n\n    logger.opt(depth=depth, exception=record.exc_info).log(\n        level, record.getMessage()\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.add_level","title":"add_level","text":"<pre><code>add_level(\n    name: str,\n    no: int | None = None,\n    color: str | None = None,\n    icon: str | None = None,\n) -&gt; Level\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_add_level.py</code> <pre><code>def add_level(\n    name: str, no: int | None = None, color: str | None = None, icon: str | None = None\n) -&gt; \"loguru.Level\":\n    core: loguru._logger.Core = logger._core  # pyright: ignore[reportAttributeAccessIssue] # noqa: SLF001\n    if name in core.levels and no == logger.level(name).no:\n        no = None  # skip update severity no\n    return logger.level(name=name, no=no, color=color, icon=icon)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.clear_stdlib_handlers","title":"clear_stdlib_handlers","text":"<pre><code>clear_stdlib_handlers() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_std_intercept.py</code> <pre><code>def clear_stdlib_handlers() -&gt; None:\n    for std_logger in logging.root.manager.loggerDict.values():\n        if isinstance(std_logger, logging.PlaceHolder):\n            continue\n        std_logger.handlers.clear()\n        std_logger.propagate = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.new_format","title":"new_format","text":"<pre><code>new_format(\n    template: str = DEFAULT_FORMAT,\n) -&gt; FormatFunction\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_format.py</code> <pre><code>def new_format(template: str = DEFAULT_FORMAT) -&gt; \"loguru.FormatFunction\":\n    template = template.strip() + \"\\n\"\n\n    def format_(record: \"loguru.Record\", /) -&gt; str:\n        if record[\"exception\"] is None:\n            return template\n        exc_type: type[BaseException] | None\n        exc_value: BaseException | None\n        traceback: types.TracebackType | None\n        exc_type, exc_value, traceback = record[\"exception\"]\n        if exc_type is None or exc_value is None:\n            return template + \"{exception}\\n\"\n        console: Console = pretty.get_console(color_system=None)\n        rich_tb: Traceback = rich_traceback(exc_type, exc_value, traceback, width=128)\n        with console.capture() as capture:\n            console.print(rich_tb)\n        record[\"extra\"][\"rich_traceback\"] = capture.get()\n        return template + \"{extra[rich_traceback]}\\n\"\n\n    return format_\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.patch_loguru_get_frame","title":"patch_loguru_get_frame","text":"<pre><code>patch_loguru_get_frame(\n    new: Callable[[int], FrameType | None] = _get_frame,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_get_frame.py</code> <pre><code>def patch_loguru_get_frame(\n    new: Callable[[int], types.FrameType | None] = _get_frame,\n) -&gt; None:\n    # ! dirty hack\n    patcher = unittest.mock.patch(\"loguru._logger.get_frame\", new)\n    patcher.start()\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.rich_traceback","title":"rich_traceback","text":"<pre><code>rich_traceback(\n    exc_type: type[BaseException],\n    exc_value: BaseException,\n    traceback: TracebackType | None,\n    /,\n    **kwargs: Unpack[TracebackOptions],\n) -&gt; Traceback\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_traceback.py</code> <pre><code>def rich_traceback(\n    exc_type: type[BaseException],\n    exc_value: BaseException,\n    traceback: types.TracebackType | None,\n    /,\n    **kwargs: Unpack[TracebackOptions],\n) -&gt; Traceback:\n    kwargs = toolz.merge(config.traceback.model_dump(), kwargs)\n    kwargs = cast(\"TracebackOptions\", kwargs)\n    if kwargs.get(\"width\") is None:\n        kwargs[\"width\"] = pretty.get_console(stderr=True).width\n    if suppress := kwargs.get(\"suppress\"):\n        kwargs[\"suppress\"] = _validate_suppress(suppress)\n    traceback = _filter_traceback(traceback)\n    # ? dirty hack to avoid long `repr()` output\n    # ref: &lt;https://github.com/Textualize/rich/discussions/3774&gt;\n    with unittest.mock.patch(\"rich.pretty.repr\", new=pretty.pformat):\n        rich_tb: Traceback = Traceback.from_exception(\n            exc_type, exc_value, traceback, **kwargs\n        )\n    # ? dirty hack to support ANSI in exception messages\n    for stack in rich_tb.trace.stacks:\n        if pretty.has_ansi(stack.exc_value):\n            stack.exc_value = Text.from_ansi(stack.exc_value)  # pyright: ignore[reportAttributeAccessIssue]\n    return rich_tb\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.setup_excepthook","title":"setup_excepthook","text":"<pre><code>setup_excepthook(level: int | str = 'CRITICAL') -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_excepthook.py</code> <pre><code>def setup_excepthook(level: int | str = \"CRITICAL\") -&gt; None:\n    def excepthook(\n        exc_type: type[BaseException],\n        exc_value: BaseException,\n        exc_traceback: types.TracebackType | None,\n        /,\n    ) -&gt; None:\n        logger.opt(exception=(exc_type, exc_value, exc_traceback)).patch(_patcher).log(\n            level, exc_value\n        )\n\n    sys.excepthook = excepthook\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.setup_icecream","title":"setup_icecream","text":"<pre><code>setup_icecream(prefix: str = '') -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_icecream.py</code> <pre><code>def setup_icecream(prefix: str = \"\") -&gt; None:\n    try:\n        from icecream import ic\n    except ImportError:\n        return\n\n    add_level(name=\"ICECREAM\", no=15, color=\"&lt;magenta&gt;&lt;bold&gt;\", icon=\"\ud83c\udf66\")\n\n    def output_function(s: str) -&gt; None:\n        logger.opt(depth=2).log(\"ICECREAM\", s)\n\n    ic.configureOutput(\n        prefix=prefix,\n        argToStringFunction=pretty.pformat,\n        outputFunction=output_function,\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.setup_loguru_intercept","title":"setup_loguru_intercept","text":"<pre><code>setup_loguru_intercept(\n    level: int | str = NOTSET, modules: Iterable[str] = ()\n) -&gt; None\n</code></pre> <p>Logs to loguru from Python logging module.</p> References <ol> <li>Entirely compatible with standard logging</li> <li>loguru-logging-intercept/loguru_logging_intercept.py at f358b75ef4162ea903bf7a3298c22b1be83110da \u00b7 MatthewScholefield/loguru-logging-intercept</li> </ol> Source code in <code>src/liblaf/grapes/logging/helpers/_std_intercept.py</code> <pre><code>def setup_loguru_intercept(\n    level: int | str = logging.NOTSET, modules: Iterable[str] = ()\n) -&gt; None:\n    \"\"\"Logs to loguru from Python logging module.\n\n    References:\n        1. [Entirely compatible with standard logging](https://loguru.readthedocs.io/en/stable/overview.html#entirely-compatible-with-standard-logging)\n        2. [loguru-logging-intercept/loguru_logging_intercept.py at f358b75ef4162ea903bf7a3298c22b1be83110da \u00b7 MatthewScholefield/loguru-logging-intercept](https://github.com/MatthewScholefield/loguru-logging-intercept/blob/f358b75ef4162ea903bf7a3298c22b1be83110da/loguru_logging_intercept.py)\n    \"\"\"\n    core: loguru._logger.Core = logger._core  # pyright: ignore[reportAttributeAccessIssue] # noqa: SLF001\n    for loguru_level in core.levels.values():\n        logging.addLevelName(loguru_level.no, loguru_level.name)\n    if isinstance(level, str):\n        level = logger.level(level).no\n    logging.basicConfig(handlers=[InterceptHandler()], level=level)\n    clear_stdlib_handlers()\n    for logger_name in itertools.chain((\"\",), modules):\n        mod_logger: logging.Logger = logging.getLogger(logger_name)\n        mod_logger.handlers = [InterceptHandler()]\n        mod_logger.propagate = False\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/helpers/#liblaf.grapes.logging.helpers.setup_unraisablehook","title":"setup_unraisablehook","text":"<pre><code>setup_unraisablehook(level: int | str = 'ERROR') -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/helpers/_unraisablehook.py</code> <pre><code>def setup_unraisablehook(level: int | str = \"ERROR\") -&gt; None:\n    def unraisablehook(args: \"sys.UnraisableHookArgs\", /) -&gt; None:\n        if logger is None:  # logger has been cleaned up\n            return\n        logger.opt(exception=(args.exc_type, args.exc_value, args.exc_traceback)).log(\n            level,\n            \"{err_msg}: {object!r}\",\n            err_msg=args.err_msg or \"Exception ignored in\",\n            object=args.object,\n        )\n\n    sys.unraisablehook = unraisablehook\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/","title":"sink","text":""},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink","title":"liblaf.grapes.logging.sink","text":"<p>Modules:</p> <ul> <li> <code>columns</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>RichSink</code>           \u2013            </li> <li> <code>RichSinkColumn</code>           \u2013            </li> <li> <code>RichSinkColumnElapsed</code>           \u2013            </li> <li> <code>RichSinkColumnLevel</code>           \u2013            </li> <li> <code>RichSinkColumnLocation</code>           \u2013            </li> <li> <code>RichSinkColumnMessage</code>           \u2013            </li> <li> <code>RichSinkColumnTime</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>default_columns</code>             \u2013              </li> <li> <code>default_console</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSink","title":"RichSink","text":"<pre><code>RichSink(\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n)\n</code></pre> <p>Parameters:</p> <ul> <li> <code>columns</code>               (<code>Sequence[RichSinkColumn]</code>, default:                   <code>&lt;dynamic&gt;</code> )           \u2013            </li> <li> <code>console</code>               (<code>Console</code>, default:                   <code>&lt;console width=128 None&gt;</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__call__</code>             \u2013              </li> <li> <code>render</code>             \u2013              </li> <li> <code>render_exception</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>columns</code>               (<code>Sequence[RichSinkColumn]</code>)           \u2013            </li> <li> <code>console</code>               (<code>Console</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def __init__(\n    self,\n    columns: Sequence[RichSinkColumn] | None = None,\n    console: Console | None = None,\n    *,\n    enable_link: bool = True,\n) -&gt; None:\n    if columns is None:\n        columns = default_columns(enable_link=enable_link)\n    self.__attrs_init__(columns=columns, console=console)  # pyright: ignore[reportAttributeAccessIssue]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSink.columns","title":"columns  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>columns: Sequence[RichSinkColumn] = field(\n    converter=default_if_none(factory=default_columns),\n    factory=default_columns,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSink.console","title":"console  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>console: Console = field(\n    converter=default_if_none(factory=default_console),\n    factory=default_console,\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSink.__call__","title":"__call__","text":"<pre><code>__call__(message: Message) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def __call__(self, message: \"loguru.Message\", /) -&gt; None:\n    record: loguru.Record = message.record\n    # TODO: `console.print()` is slow\n    self.console.print(\n        *self.render(record), overflow=\"ignore\", no_wrap=True, crop=False\n    )\n    if (excpetion := self.render_exception(record)) is not None:\n        self.console.print(excpetion)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSink.render","title":"render","text":"<pre><code>render(record: Record) -&gt; Generator[RenderableType]\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def render(self, record: \"loguru.Record\", /) -&gt; Generator[RenderableType]:\n    for column in self.columns:\n        yield column.render(record)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSink.render_exception","title":"render_exception","text":"<pre><code>render_exception(record: Record) -&gt; RenderableType | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def render_exception(self, record: \"loguru.Record\", /) -&gt; RenderableType | None:\n    exception: loguru.RecordException | None = record[\"exception\"]\n    if exception is None:\n        return None\n    exc_type: type[BaseException] | None\n    exc_value: BaseException | None\n    traceback: types.TracebackType | None\n    exc_type, exc_value, traceback = exception\n    if exc_type is None or exc_value is None:\n        return None\n    return rich_traceback(exc_type, exc_value, traceback)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumn","title":"RichSinkColumn","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumn.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_abc.py</code> <pre><code>@abc.abstractmethod\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnElapsed","title":"RichSinkColumnElapsed","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnElapsed.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_elapsed.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    elapsed: datetime.timedelta = record[\"elapsed\"]\n    hh: int\n    mm: int\n    ss: int\n    mm, ss = divmod(int(elapsed.total_seconds()), 60)\n    hh, mm = divmod(mm, 60)\n    # TODO: handle longer timedelta\n    # ref: &lt;https://docs.pydantic.dev/latest/api/standard_library_types/#datetimetimedelta&gt;\n    # format: [[DD]D,]HH:MM:SS[.ffffff]\n    # Ex: '1d,01:02:03.000004' or '1D01:02:03.000004' or '01:02:03'\n    return Text(\n        f\"{hh:02d}:{mm:02d}:{ss:02d}.{elapsed.microseconds:06d}\", style=\"log.time\"\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLevel","title":"RichSinkColumnLevel","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLevel.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int = 1\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLevel.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_level.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    level: str = record[\"level\"].name\n    return Text(f\"{level:&lt;.{self.width}}\", style=f\"logging.level.{level.lower()}\")\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLocation","title":"RichSinkColumnLocation","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>abbr_name</code>               (<code>str</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>enable_link</code>               (<code>str</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>width</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> <li> <code>render_name</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>abbr_name</code>               (<code>bool</code>)           \u2013            </li> <li> <code>enable_link</code>               (<code>bool</code>)           \u2013            </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLocation.abbr_name","title":"abbr_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>abbr_name: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLocation.enable_link","title":"enable_link  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_link: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLocation.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLocation.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_location.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: loguru.Record, /) -&gt; RenderableType:\n    name: str | None = self.render_name(record)\n    location: Text = pretty.rich_location(\n        name=name,\n        function=record[\"function\"],\n        line=record[\"line\"],\n        file=record[\"file\"].path,\n        enable_link=self.enable_link,\n        width=self.width,\n    )\n    location.style = \"log.path\"\n    return location\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnLocation.render_name","title":"render_name","text":"<pre><code>render_name(record: Record) -&gt; str | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_location.py</code> <pre><code>def render_name(self, record: loguru.Record) -&gt; str | None:\n    name: str | None = record[\"name\"]\n    if name is None:\n        return None\n    if not self.abbr_name:\n        return name\n    function: str = record[\"function\"]\n    start: int = 0\n    while True:\n        index: int = name.find(\".\", start)\n        if index &lt; 0:\n            return name\n        module_name: str = name[:index]\n        module: types.ModuleType | None = sys.modules.get(module_name)\n        if module is None:\n            return name\n        if hasattr(module, function):\n            return module_name\n        start = index + 1\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnMessage","title":"RichSinkColumnMessage","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>highlighter</code>               (<code>Highlighter</code>, default:                   <code>&lt;rich.highlighter.ReprHighlighter object at 0x7f690bf39090&gt;</code> )           \u2013            <p>Highlights the text typically produced from <code>__repr__</code> methods.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>highlighter</code>               (<code>Highlighter</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnMessage.highlighter","title":"highlighter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlighter: Highlighter = field(factory=ReprHighlighter)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnMessage.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_message.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\") -&gt; RenderableType:\n    if (rich := record[\"extra\"].get(\"rich\")) is not None:\n        return rich\n    message: RenderableType = record[\"message\"].strip()\n    if \"\\x1b\" in message:\n        return Text.from_ansi(message)\n    if record[\"extra\"].get(\"markup\", True):\n        message = Text.from_markup(message)\n    if highlighter := record[\"extra\"].get(\"highlighter\", self.highlighter):\n        message = highlighter(message)\n    return message\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnTime","title":"RichSinkColumnTime","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'%Y-%m-%dT%H:%M:%S.%f'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>fmt</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnTime.fmt","title":"fmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmt: str = '%Y-%m-%dT%H:%M:%S.%f'\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.RichSinkColumnTime.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_time.py</code> <pre><code>def render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    time: datetime.datetime = record[\"time\"]\n    return Text(f\"{time:{self.fmt}}\", style=\"log.time\")\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.default_columns","title":"default_columns","text":"<pre><code>default_columns(\n    *, enable_link: bool = True\n) -&gt; Sequence[RichSinkColumn]\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def default_columns(*, enable_link: bool = True) -&gt; Sequence[RichSinkColumn]:\n    return [\n        RichSinkColumnElapsed(),\n        RichSinkColumnLevel(),\n        RichSinkColumnLocation(enable_link=enable_link),\n        RichSinkColumnMessage(),\n    ]\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/#liblaf.grapes.logging.sink.default_console","title":"default_console","text":"<pre><code>default_console() -&gt; Console\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/_sink.py</code> <pre><code>def default_console() -&gt; Console:\n    return pretty.get_console(stderr=True)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/","title":"columns","text":""},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns","title":"liblaf.grapes.logging.sink.columns","text":"<p>Classes:</p> <ul> <li> <code>RichSinkColumn</code>           \u2013            </li> <li> <code>RichSinkColumnElapsed</code>           \u2013            </li> <li> <code>RichSinkColumnLevel</code>           \u2013            </li> <li> <code>RichSinkColumnLocation</code>           \u2013            </li> <li> <code>RichSinkColumnMessage</code>           \u2013            </li> <li> <code>RichSinkColumnTime</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumn","title":"RichSinkColumn","text":"<p>               Bases: <code>ABC</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumn.render","title":"render  <code>abstractmethod</code>","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_abc.py</code> <pre><code>@abc.abstractmethod\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnElapsed","title":"RichSinkColumnElapsed","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnElapsed.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_elapsed.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    elapsed: datetime.timedelta = record[\"elapsed\"]\n    hh: int\n    mm: int\n    ss: int\n    mm, ss = divmod(int(elapsed.total_seconds()), 60)\n    hh, mm = divmod(mm, 60)\n    # TODO: handle longer timedelta\n    # ref: &lt;https://docs.pydantic.dev/latest/api/standard_library_types/#datetimetimedelta&gt;\n    # format: [[DD]D,]HH:MM:SS[.ffffff]\n    # Ex: '1d,01:02:03.000004' or '1D01:02:03.000004' or '01:02:03'\n    return Text(\n        f\"{hh:02d}:{mm:02d}:{ss:02d}.{elapsed.microseconds:06d}\", style=\"log.time\"\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLevel","title":"RichSinkColumnLevel","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>width</code>               (<code>int</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLevel.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int = 1\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLevel.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_level.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    level: str = record[\"level\"].name\n    return Text(f\"{level:&lt;.{self.width}}\", style=f\"logging.level.{level.lower()}\")\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLocation","title":"RichSinkColumnLocation","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>abbr_name</code>               (<code>str</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>enable_link</code>               (<code>str</code>, default:                   <code>True</code> )           \u2013            </li> <li> <code>width</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> <li> <code>render_name</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>abbr_name</code>               (<code>bool</code>)           \u2013            </li> <li> <code>enable_link</code>               (<code>bool</code>)           \u2013            </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLocation.abbr_name","title":"abbr_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>abbr_name: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLocation.enable_link","title":"enable_link  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>enable_link: bool = True\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLocation.width","title":"width  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>width: int | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLocation.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_location.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: loguru.Record, /) -&gt; RenderableType:\n    name: str | None = self.render_name(record)\n    location: Text = pretty.rich_location(\n        name=name,\n        function=record[\"function\"],\n        line=record[\"line\"],\n        file=record[\"file\"].path,\n        enable_link=self.enable_link,\n        width=self.width,\n    )\n    location.style = \"log.path\"\n    return location\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnLocation.render_name","title":"render_name","text":"<pre><code>render_name(record: Record) -&gt; str | None\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_location.py</code> <pre><code>def render_name(self, record: loguru.Record) -&gt; str | None:\n    name: str | None = record[\"name\"]\n    if name is None:\n        return None\n    if not self.abbr_name:\n        return name\n    function: str = record[\"function\"]\n    start: int = 0\n    while True:\n        index: int = name.find(\".\", start)\n        if index &lt; 0:\n            return name\n        module_name: str = name[:index]\n        module: types.ModuleType | None = sys.modules.get(module_name)\n        if module is None:\n            return name\n        if hasattr(module, function):\n            return module_name\n        start = index + 1\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnMessage","title":"RichSinkColumnMessage","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>highlighter</code>               (<code>Highlighter</code>, default:                   <code>&lt;rich.highlighter.ReprHighlighter object at 0x7f690bf39090&gt;</code> )           \u2013            <p>Highlights the text typically produced from <code>__repr__</code> methods.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>highlighter</code>               (<code>Highlighter</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnMessage.highlighter","title":"highlighter  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>highlighter: Highlighter = field(factory=ReprHighlighter)\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnMessage.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_message.py</code> <pre><code>@override  # impl RichSinkColumn\ndef render(self, record: \"loguru.Record\") -&gt; RenderableType:\n    if (rich := record[\"extra\"].get(\"rich\")) is not None:\n        return rich\n    message: RenderableType = record[\"message\"].strip()\n    if \"\\x1b\" in message:\n        return Text.from_ansi(message)\n    if record[\"extra\"].get(\"markup\", True):\n        message = Text.from_markup(message)\n    if highlighter := record[\"extra\"].get(\"highlighter\", self.highlighter):\n        message = highlighter(message)\n    return message\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnTime","title":"RichSinkColumnTime","text":"<p>               Bases: <code>RichSinkColumn</code></p> <p>Parameters:</p> <ul> <li> <code>fmt</code>               (<code>str</code>, default:                   <code>'%Y-%m-%dT%H:%M:%S.%f'</code> )           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>fmt</code>               (<code>str</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnTime.fmt","title":"fmt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>fmt: str = '%Y-%m-%dT%H:%M:%S.%f'\n</code></pre>"},{"location":"reference/liblaf/grapes/logging/sink/columns/#liblaf.grapes.logging.sink.columns.RichSinkColumnTime.render","title":"render","text":"<pre><code>render(record: Record) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/logging/sink/columns/_time.py</code> <pre><code>def render(self, record: \"loguru.Record\", /) -&gt; RenderableType:\n    time: datetime.datetime = record[\"time\"]\n    return Text(f\"{time:{self.fmt}}\", style=\"log.time\")\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/","title":"pretty","text":""},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty","title":"liblaf.grapes.pretty","text":"<p>Classes:</p> <ul> <li> <code>WadlerLindigOptions</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>auto_repr</code>             \u2013              </li> <li> <code>choose_duration_format</code>             \u2013              </li> <li> <code>get_console</code>             \u2013              </li> <li> <code>has_ansi</code>             \u2013              </li> <li> <code>pdoc_attrs</code>             \u2013              <p>.</p> </li> <li> <code>pdoc_custom</code>             \u2013              </li> <li> <code>pformat</code>             \u2013              </li> <li> <code>pretty_call</code>             \u2013              </li> <li> <code>pretty_duration</code>             \u2013              <p>.</p> </li> <li> <code>pretty_func</code>             \u2013              </li> <li> <code>pretty_throughput</code>             \u2013              </li> <li> <code>rich_location</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions","title":"WadlerLindigOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> <li> <code>indent</code>               (<code>int</code>)           \u2013            </li> <li> <code>short_arrays</code>               (<code>bool</code>)           \u2013            </li> <li> <code>custom</code>               (<code>Callable[list, Optional[AbstractDoc]]</code>)           \u2013            </li> <li> <code>hide_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_type_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_dataclass_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_function_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>respect_pdoc</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays_threshold</code>               (<code>int</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>custom</code>               (<code>Callable[[Any], AbstractDoc | None]</code>)           \u2013            </li> <li> <code>hide_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>indent</code>               (<code>int</code>)           \u2013            </li> <li> <code>respect_pdoc</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays</code>               (<code>bool</code>)           \u2013            </li> <li> <code>short_arrays_threshold</code>               (<code>int</code>)           \u2013            </li> <li> <code>show_dataclass_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_function_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>show_type_module</code>               (<code>bool</code>)           \u2013            </li> <li> <code>width</code>               (<code>int | None</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.custom","title":"custom  <code>instance-attribute</code>","text":"<pre><code>custom: Callable[[Any], AbstractDoc | None]\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.hide_defaults","title":"hide_defaults  <code>instance-attribute</code>","text":"<pre><code>hide_defaults: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.indent","title":"indent  <code>instance-attribute</code>","text":"<pre><code>indent: int\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.respect_pdoc","title":"respect_pdoc  <code>instance-attribute</code>","text":"<pre><code>respect_pdoc: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.short_arrays","title":"short_arrays  <code>instance-attribute</code>","text":"<pre><code>short_arrays: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.short_arrays_threshold","title":"short_arrays_threshold  <code>instance-attribute</code>","text":"<pre><code>short_arrays_threshold: int\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.show_dataclass_module","title":"show_dataclass_module  <code>instance-attribute</code>","text":"<pre><code>show_dataclass_module: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.show_function_module","title":"show_function_module  <code>instance-attribute</code>","text":"<pre><code>show_function_module: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.show_type_module","title":"show_type_module  <code>instance-attribute</code>","text":"<pre><code>show_type_module: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.WadlerLindigOptions.width","title":"width  <code>instance-attribute</code>","text":"<pre><code>width: int | None\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.auto_repr","title":"auto_repr","text":"<pre><code>auto_repr(\n    cls: T,\n    *,\n    repr: bool | None = None,\n    pdoc: bool | None = None,\n) -&gt; T\n</code></pre><pre><code>auto_repr(\n    *, repr: bool | None = None, pdoc: bool | None = None\n) -&gt; Callable[[T], T]\n</code></pre> <pre><code>auto_repr(\n    cls: type | None = None,\n    *,\n    repr: bool | None = None,\n    pdoc: bool | None = None,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_auto_repr.py</code> <pre><code>def auto_repr(\n    cls: type | None = None,\n    *,\n    repr: bool | None = None,  # noqa: A002\n    pdoc: bool | None = None,\n) -&gt; Any:\n    if cls is None:\n        return functools.partial(auto_repr, repr=repr, pdoc=pdoc)\n    if repr or (repr is None and \"__repr__\" not in cls.__dict__):\n        cls.__repr__ = lambda self: pformat(self)  # pyright: ignore[reportAttributeAccessIssue]\n    if (pdoc or (pdoc is None and \"__pdoc__\" not in cls.__dict__)) and attrs.has(cls):\n        cls.__pdoc__ = pdoc_attrs  # pyright: ignore[reportAttributeAccessIssue]\n    return cls\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.choose_duration_format","title":"choose_duration_format","text":"<pre><code>choose_duration_format(seconds: float) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_duration.py</code> <pre><code>def choose_duration_format(seconds: float) -&gt; str:\n    for prec, threshold, fmt in FORMATS:\n        if round(seconds, prec) &lt; threshold:\n            return fmt\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.get_console","title":"get_console  <code>cached</code>","text":"<pre><code>get_console(**kwargs) -&gt; Console\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_console.py</code> <pre><code>@clone_param_spec(Console)\n@functools.cache\ndef get_console(**kwargs) -&gt; Console:\n    if kwargs.get(\"theme\") is None:\n        kwargs[\"theme\"] = default_theme()\n    file: IO[str] | None = kwargs.get(\"file\")\n    stderr: bool = file is None and kwargs.get(\"stderr\", False)\n    stdout: bool = file is None and not stderr\n    if (\n        (stdout and not sys.stdout.isatty())\n        or (stderr and not sys.stderr.isatty())\n        or (file is not None and not os.isatty(file.fileno()))\n    ):\n        kwargs.setdefault(\"width\", 128)\n    if stdout:\n        rich.reconfigure(**kwargs)\n        return rich.get_console()\n    return Console(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.has_ansi","title":"has_ansi","text":"<pre><code>has_ansi(s: str) -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_ansi.py</code> <pre><code>def has_ansi(s: str, /) -&gt; bool:\n    return \"\\x1b\" in s\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pdoc_attrs","title":"pdoc_attrs","text":"<pre><code>pdoc_attrs(\n    self: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; AbstractDoc\n</code></pre> <p>.</p> References <ol> <li>https://github.com/patrick-kidger/wadler_lindig/blob/0226340d56f0c18e10cd4d375cf7ea25818359b8/wadler_lindig/_definitions.py#L308-L326</li> </ol> Source code in <code>src/liblaf/grapes/pretty/_wadler_lindig.py</code> <pre><code>def pdoc_attrs(self: Any, **kwargs: Unpack[WadlerLindigOptions]) -&gt; wl.AbstractDoc:\n    \"\"\".\n\n    References:\n        1. &lt;https://github.com/patrick-kidger/wadler_lindig/blob/0226340d56f0c18e10cd4d375cf7ea25818359b8/wadler_lindig/_definitions.py#L308-L326&gt;\n    \"\"\"\n    kwargs: WadlerLindigOptions = _make_kwargs(kwargs)\n    cls: type = type(self)\n    objs: list[tuple[str, Any]] = []\n    for field in attrs.fields(cls):\n        field: attrs.Attribute\n        if not field.repr:\n            continue\n        value: Any = getattr(self, field.name, UNINITIALIZED)\n        if kwargs.get(\"hide_defaults\", True) and value is field.default:\n            continue\n        objs.append((field.name, value))\n    name_kwargs: dict[str, Any] = toolz.assoc(\n        kwargs, \"show_type_module\", kwargs.get(\"show_dataclass_module\", False)\n    )\n    return wl.bracketed(\n        begin=wl.pdoc(cls, **name_kwargs) + wl.TextDoc(\"(\"),\n        docs=wl.named_objs(objs, **kwargs),\n        sep=wl.comma,\n        end=wl.TextDoc(\")\"),\n        indent=kwargs.get(\"indent\", 2),\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pdoc_custom","title":"pdoc_custom","text":"<pre><code>pdoc_custom(\n    obj: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; AbstractDoc | None\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_wadler_lindig.py</code> <pre><code>@functools.singledispatch\ndef pdoc_custom(\n    obj: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; wl.AbstractDoc | None:\n    if hasattr(obj, \"__pdoc__\"):\n        return None\n    if attrs.has(type(obj)):\n        return pdoc_attrs(obj, **kwargs)\n    if (size := _array_size(obj)) is not None:\n        if kwargs.get(\"short_arrays\") is None:\n            try:\n                kwargs[\"short_arrays\"] = size &gt; kwargs.get(\n                    \"short_arrays_threshold\", 100\n                )\n            except TypeError:\n                kwargs[\"short_arrays\"] = True\n        return wl.pdoc(obj, **kwargs)\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pformat","title":"pformat","text":"<pre><code>pformat(\n    obj: Any, **kwargs: Unpack[WadlerLindigOptions]\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_wadler_lindig.py</code> <pre><code>@functools.singledispatch\ndef pformat(obj: Any, **kwargs: Unpack[WadlerLindigOptions]) -&gt; str:\n    kwargs: WadlerLindigOptions = _make_kwargs(kwargs)\n    if kwargs.get(\"width\") is None:\n        kwargs[\"width\"] = get_console(stderr=True).width\n    if kwargs.get(\"custom\") is None:\n        kwargs[\"custom\"] = functools.partial(pdoc_custom, **kwargs)\n    return wl.pformat(obj, **kwargs)  # pyright: ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pretty_call","title":"pretty_call","text":"<pre><code>pretty_call(\n    func: Callable,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    **wl_kwargs,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_call.py</code> <pre><code>def pretty_call(\n    func: Callable,\n    args: Sequence[Any] = (),\n    kwargs: Mapping[str, Any] = {},\n    **wl_kwargs,\n) -&gt; str:\n    func = inspect.unwrap(func)\n    args, kwargs = _bind_safe(func, args, kwargs)\n    return pformat(PrettyCall(func, args, kwargs), **wl_kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pretty_duration","title":"pretty_duration","text":"<pre><code>pretty_duration(\n    seconds: float, fmt: str | None = None\n) -&gt; str\n</code></pre> <p>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pretty_duration(math.nan)\n'?? s'\n&gt;&gt;&gt; pretty_duration(1e-12)\n'0.00 ns'\n&gt;&gt;&gt; pretty_duration(1e-11)\n'0.01 ns'\n&gt;&gt;&gt; pretty_duration(1e-10)\n'0.10 ns'\n&gt;&gt;&gt; pretty_duration(1e-9)\n'1.00 ns'\n&gt;&gt;&gt; pretty_duration(1e-8)\n'10.0 ns'\n&gt;&gt;&gt; pretty_duration(1e-7)\n'100. ns'\n&gt;&gt;&gt; pretty_duration(1e-6)\n'1.00 \u00b5s'\n&gt;&gt;&gt; pretty_duration(1e-5)\n'10.0 \u00b5s'\n&gt;&gt;&gt; pretty_duration(1e-4)\n'100. \u00b5s'\n&gt;&gt;&gt; pretty_duration(1e-3)\n'1.00 ms'\n&gt;&gt;&gt; pretty_duration(1e-2)\n'10.0 ms'\n&gt;&gt;&gt; pretty_duration(1e-1)\n'100. ms'\n&gt;&gt;&gt; pretty_duration(1.0)\n'1.00 s'\n&gt;&gt;&gt; pretty_duration(1e1)\n'10.0 s'\n&gt;&gt;&gt; pretty_duration(1e2)\n'01:40'\n&gt;&gt;&gt; pretty_duration(1e3)\n'16:40'\n&gt;&gt;&gt; pretty_duration(1e4)\n'02:46:40'\n&gt;&gt;&gt; pretty_duration(1e5)\n'1d,03:46:40'\n&gt;&gt;&gt; pretty_duration(1e6)\n'11d,13:46:40'\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_duration.py</code> <pre><code>def pretty_duration(seconds: float, fmt: str | None = None) -&gt; str:  # noqa: C901, PLR0911, PLR0912\n    \"\"\".\n\n    Examples:\n        &gt;&gt;&gt; pretty_duration(math.nan)\n        '?? s'\n        &gt;&gt;&gt; pretty_duration(1e-12)\n        '0.00 ns'\n        &gt;&gt;&gt; pretty_duration(1e-11)\n        '0.01 ns'\n        &gt;&gt;&gt; pretty_duration(1e-10)\n        '0.10 ns'\n        &gt;&gt;&gt; pretty_duration(1e-9)\n        '1.00 ns'\n        &gt;&gt;&gt; pretty_duration(1e-8)\n        '10.0 ns'\n        &gt;&gt;&gt; pretty_duration(1e-7)\n        '100. ns'\n        &gt;&gt;&gt; pretty_duration(1e-6)\n        '1.00 \u00b5s'\n        &gt;&gt;&gt; pretty_duration(1e-5)\n        '10.0 \u00b5s'\n        &gt;&gt;&gt; pretty_duration(1e-4)\n        '100. \u00b5s'\n        &gt;&gt;&gt; pretty_duration(1e-3)\n        '1.00 ms'\n        &gt;&gt;&gt; pretty_duration(1e-2)\n        '10.0 ms'\n        &gt;&gt;&gt; pretty_duration(1e-1)\n        '100. ms'\n        &gt;&gt;&gt; pretty_duration(1.0)\n        '1.00 s'\n        &gt;&gt;&gt; pretty_duration(1e1)\n        '10.0 s'\n        &gt;&gt;&gt; pretty_duration(1e2)\n        '01:40'\n        &gt;&gt;&gt; pretty_duration(1e3)\n        '16:40'\n        &gt;&gt;&gt; pretty_duration(1e4)\n        '02:46:40'\n        &gt;&gt;&gt; pretty_duration(1e5)\n        '1d,03:46:40'\n        &gt;&gt;&gt; pretty_duration(1e6)\n        '11d,13:46:40'\n    \"\"\"\n    if not math.isfinite(seconds):\n        return \"?? s\"\n    if fmt is None:\n        fmt = choose_duration_format(seconds)\n    fmt = fmt.replace(\"us\", \"\u00b5s\")\n    match fmt:\n        case \"9.99 ns\":\n            return f\"{seconds * 1e9:#.2f} ns\"\n        case \"99.9 ns\":\n            return f\"{seconds * 1e9:#.1f} ns\"\n        case \"999. ns\":\n            return f\"{seconds * 1e9:#.0f} ns\"\n        case \"9.99 \u00b5s\":\n            return f\"{seconds * 1e6:#.2f} \u00b5s\"\n        case \"99.9 \u00b5s\":\n            return f\"{seconds * 1e6:#.1f} \u00b5s\"\n        case \"999. \u00b5s\":\n            return f\"{seconds * 1e6:#.0f} \u00b5s\"\n        case \"9.99 ms\":\n            return f\"{seconds * 1e3:#.2f} ms\"\n        case \"99.9 ms\":\n            return f\"{seconds * 1e3:#.1f} ms\"\n        case \"999. ms\":\n            return f\"{seconds * 1e3:#.0f} ms\"\n        case \"9.99 s\":\n            return f\"{seconds:#.2f} s\"\n        case \"99.9 s\":\n            return f\"{seconds:#.1f} s\"\n        case \"999. s\":\n            return f\"{seconds:#.0f} s\"\n        case \"59:59\":\n            minutes: int\n            seconds: int\n            seconds = round(seconds)\n            minutes, seconds = divmod(seconds, 60)\n            return f\"{minutes:02d}:{seconds:02d}\"\n        case \"23:59:59\":\n            hours: int\n            minutes: int\n            seconds = round(seconds)\n            hours, seconds = divmod(seconds, 3600)\n            minutes, seconds = divmod(seconds, 60)\n            return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n        case \"1d,23:59:59\":\n            days: int\n            hours: int\n            minutes: int\n            seconds = round(seconds)\n            days, seconds = divmod(seconds, 86400)\n            hours, seconds = divmod(seconds, 3600)\n            minutes, seconds = divmod(seconds, 60)\n            return f\"{days}d,{hours:02d}:{minutes:02d}:{seconds:02d}\"\n        case _:\n            raise MatchError(fmt, \"format\")\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pretty_func","title":"pretty_func","text":"<pre><code>pretty_func(func: Callable) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_func.py</code> <pre><code>def pretty_func(func: Callable, /) -&gt; str:\n    name: str = get_name(func)\n    return f\"{name}()\"\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.pretty_throughput","title":"pretty_throughput","text":"<pre><code>pretty_throughput(value: float, unit: str = '') -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_throughput.py</code> <pre><code>def pretty_throughput(value: float, unit: str = \"\") -&gt; str:\n    throughput: about_time.HumanThroughput = about_time.HumanThroughput(value, unit)\n    return throughput.as_human()\n</code></pre>"},{"location":"reference/liblaf/grapes/pretty/#liblaf.grapes.pretty.rich_location","title":"rich_location","text":"<pre><code>rich_location(\n    name: str | None,\n    function: str | None,\n    line: int | None,\n    file: PathLike | None = None,\n    *,\n    enable_link: bool = True,\n    width: int | None = None,\n) -&gt; Text\n</code></pre> Source code in <code>src/liblaf/grapes/pretty/_location.py</code> <pre><code>def rich_location(\n    name: str | None,\n    function: str | None,\n    line: int | None,\n    file: PathLike | None = None,\n    *,\n    enable_link: bool = True,\n    width: int | None = None,\n) -&gt; Text:\n    name = name or \"&lt;unknown&gt;\"\n    function = function or \"&lt;unknown&gt;\"\n    line = line or 0\n    file: Path | None = Path(file) if file is not None else None\n    func_line: str = f\":{function}:{line}\"\n    if width and len(name) + len(func_line) &gt; width:\n        name = name[: width - len(func_line) - 1] + \"\u2026\"\n    if enable_link and file is not None and file.exists():\n        return Text(\n            f\"{name}:{function}:{line}\", style=Style(link=f\"{file.as_uri()}#{line}\")\n        )\n    return Text(f\"{name}:{function}:{line}\")\n</code></pre>"},{"location":"reference/liblaf/grapes/sentinel/","title":"sentinel","text":""},{"location":"reference/liblaf/grapes/sentinel/#liblaf.grapes.sentinel","title":"liblaf.grapes.sentinel","text":"<p>Functions:</p> <ul> <li> <code>nop</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>MISSING</code>           \u2013            </li> <li> <code>NOP</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/sentinel/#liblaf.grapes.sentinel.MISSING","title":"MISSING  <code>module-attribute</code>","text":"<pre><code>MISSING = Sentinel('MISSING')\n</code></pre>"},{"location":"reference/liblaf/grapes/sentinel/#liblaf.grapes.sentinel.NOP","title":"NOP  <code>module-attribute</code>","text":"<pre><code>NOP = Sentinel('NOP')\n</code></pre>"},{"location":"reference/liblaf/grapes/sentinel/#liblaf.grapes.sentinel.nop","title":"nop","text":"<pre><code>nop(*args, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/sentinel/_function.py</code> <pre><code>def nop(*args, **kwargs) -&gt; None: ...\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/","title":"serde","text":""},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde","title":"liblaf.grapes.serde","text":"<p>This module provides functions for serialization and deserialization of various data formats, including JSON, TOML, YAML, and Pydantic models. It also includes registries for mapping file extensions to their respective serialization and deserialization functions.</p> <p>Type Aliases:</p> <ul> <li> <code>DecHook</code>           \u2013            </li> <li> <code>EncHook</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>PydanticModelDumpOptions</code>           \u2013            </li> <li> <code>PydanticModelValidateOptions</code>           \u2013            </li> <li> <code>Serde</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>dec_hook</code>             \u2013              </li> <li> <code>enc_hook</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>json</code>           \u2013            </li> <li> <code>toml</code>           \u2013            </li> <li> <code>yaml</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.json","title":"json  <code>module-attribute</code>","text":"<pre><code>json = Serde(decoder=decode, encoder=encode)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.toml","title":"toml  <code>module-attribute</code>","text":"<pre><code>toml = Serde(decoder=decode, encoder=encode)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.yaml","title":"yaml  <code>module-attribute</code>","text":"<pre><code>yaml = Serde(decoder=decode, encoder=encode)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.DecHook","title":"DecHook","text":"<pre><code>DecHook = Callable[[type, Any], Any]\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.EncHook","title":"EncHook","text":"<pre><code>EncHook = Callable[[Any], Any]\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions","title":"PydanticModelDumpOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>mode</code>               (<code>Literal['json', 'python']</code>)           \u2013            </li> <li> <code>include</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>exclude</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            </li> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>exclude_unset</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_none</code>               (<code>bool</code>)           \u2013            </li> <li> <code>round_trip</code>               (<code>bool</code>)           \u2013            </li> <li> <code>warnings</code>               (<code>bool | Literal['none', 'warn', 'error']</code>)           \u2013            </li> <li> <code>fallback</code>               (<code>Callable[list, Any] | None</code>)           \u2013            </li> <li> <code>serialize_as_any</code>               (<code>bool</code>)           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            </li> <li> <code>exclude</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>exclude_defaults</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_none</code>               (<code>bool</code>)           \u2013            </li> <li> <code>exclude_unset</code>               (<code>bool</code>)           \u2013            </li> <li> <code>fallback</code>               (<code>Callable[[Any], Any] | None</code>)           \u2013            </li> <li> <code>include</code>               (<code>IncEx | None</code>)           \u2013            </li> <li> <code>mode</code>               (<code>Literal['json', 'python']</code>)           \u2013            </li> <li> <code>round_trip</code>               (<code>bool</code>)           \u2013            </li> <li> <code>serialize_as_any</code>               (<code>bool</code>)           \u2013            </li> <li> <code>warnings</code>               (<code>bool | Literal['none', 'warn', 'error']</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.by_alias","title":"by_alias  <code>instance-attribute</code>","text":"<pre><code>by_alias: bool | None\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Any | None\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.exclude","title":"exclude  <code>instance-attribute</code>","text":"<pre><code>exclude: IncEx | None\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.exclude_defaults","title":"exclude_defaults  <code>instance-attribute</code>","text":"<pre><code>exclude_defaults: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.exclude_none","title":"exclude_none  <code>instance-attribute</code>","text":"<pre><code>exclude_none: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.exclude_unset","title":"exclude_unset  <code>instance-attribute</code>","text":"<pre><code>exclude_unset: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.fallback","title":"fallback  <code>instance-attribute</code>","text":"<pre><code>fallback: Callable[[Any], Any] | None\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.include","title":"include  <code>instance-attribute</code>","text":"<pre><code>include: IncEx | None\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.mode","title":"mode  <code>instance-attribute</code>","text":"<pre><code>mode: Literal['json', 'python']\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.round_trip","title":"round_trip  <code>instance-attribute</code>","text":"<pre><code>round_trip: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.serialize_as_any","title":"serialize_as_any  <code>instance-attribute</code>","text":"<pre><code>serialize_as_any: bool\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelDumpOptions.warnings","title":"warnings  <code>instance-attribute</code>","text":"<pre><code>warnings: bool | Literal['none', 'warn', 'error']\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelValidateOptions","title":"PydanticModelValidateOptions","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool | None</code>)           \u2013            <p>Whether to enforce types strictly.</p> </li> <li> <code>from_attributes</code>               (<code>bool | None</code>)           \u2013            <p>Whether to extract data from object attributes.</p> </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            <p>Additional context to pass to the validator.</p> </li> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s alias when validating against the provided input data.</p> </li> <li> <code>by_name</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s name when validating against the provided input data.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>by_alias</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s alias when validating against the provided input data.</p> </li> <li> <code>by_name</code>               (<code>bool | None</code>)           \u2013            <p>Whether to use the field\u2019s name when validating against the provided input data.</p> </li> <li> <code>context</code>               (<code>Any | None</code>)           \u2013            <p>Additional context to pass to the validator.</p> </li> <li> <code>from_attributes</code>               (<code>bool | None</code>)           \u2013            <p>Whether to extract data from object attributes.</p> </li> <li> <code>strict</code>               (<code>bool | None</code>)           \u2013            <p>Whether to enforce types strictly.</p> </li> </ul>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelValidateOptions.by_alias","title":"by_alias  <code>instance-attribute</code>","text":"<pre><code>by_alias: bool | None\n</code></pre> <p>Whether to use the field\u2019s alias when validating against the provided input data.</p>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelValidateOptions.by_name","title":"by_name  <code>instance-attribute</code>","text":"<pre><code>by_name: bool | None\n</code></pre> <p>Whether to use the field\u2019s name when validating against the provided input data.</p>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelValidateOptions.context","title":"context  <code>instance-attribute</code>","text":"<pre><code>context: Any | None\n</code></pre> <p>Additional context to pass to the validator.</p>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelValidateOptions.from_attributes","title":"from_attributes  <code>instance-attribute</code>","text":"<pre><code>from_attributes: bool | None\n</code></pre> <p>Whether to extract data from object attributes.</p>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.PydanticModelValidateOptions.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: bool | None\n</code></pre> <p>Whether to enforce types strictly.</p>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde","title":"Serde","text":"<p>Parameters:</p> <ul> <li> <code>decoder</code>               (<code>Decoder</code>)           \u2013            </li> <li> <code>encoder</code>               (<code>Encoder</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>decode</code>             \u2013              </li> <li> <code>encode</code>             \u2013              </li> <li> <code>load</code>             \u2013              </li> <li> <code>save</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>decoder</code>               (<code>Decoder</code>)           \u2013            </li> <li> <code>encoder</code>               (<code>Encoder</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde.decoder","title":"decoder  <code>instance-attribute</code>","text":"<pre><code>decoder: Decoder\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde.encoder","title":"encoder  <code>instance-attribute</code>","text":"<pre><code>encoder: Encoder\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde.decode","title":"decode","text":"<pre><code>decode(\n    buf: Buffer | str,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n) -&gt; Any\n</code></pre><pre><code>decode(\n    buf: Buffer | str,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: type[T],\n) -&gt; T\n</code></pre><pre><code>decode(\n    buf: Buffer | str,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: Any,\n) -&gt; Any\n</code></pre> <pre><code>decode(buf: Buffer | str, /, **kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def decode(self, buf: Buffer | str, /, **kwargs) -&gt; Any:\n    if \"dec_hook\" not in kwargs:\n        kwargs[\"dec_hook\"] = functools.partial(\n            dec_hook, pydantic_options=kwargs.pop(\"pydantic\", None)\n        )\n    return self.decoder(buf, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde.encode","title":"encode","text":"<pre><code>encode(\n    obj: Any,\n    /,\n    *,\n    enc_hook: EncHook | None = ...,\n    order: Literal[\"deterministic\", \"sorted\"] | None = None,\n    pydantic: PydanticModelDumpOptions | None = None,\n) -&gt; bytes\n</code></pre> <pre><code>encode(obj: Any, /, **kwargs) -&gt; bytes\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def encode(self, obj: Any, /, **kwargs) -&gt; bytes:\n    if \"enc_hook\" not in kwargs:\n        kwargs[\"enc_hook\"] = functools.partial(\n            enc_hook, pydantic_options=kwargs.pop(\"pydantic\", None)\n        )\n    return self.encoder(obj, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde.load","title":"load","text":"<pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n) -&gt; Any\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: type[T],\n) -&gt; T\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: Any,\n) -&gt; Any\n</code></pre> <pre><code>load(path: PathLike, /, **kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def load(self, path: PathLike, /, **kwargs) -&gt; Any:\n    path = Path(path)\n    return self.decode(path.read_bytes(), **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.Serde.save","title":"save","text":"<pre><code>save(\n    path: PathLike,\n    obj: Any,\n    /,\n    *,\n    enc_hook: EncHook | None = ...,\n    order: Literal[\"deterministic\", \"sorted\"] | None = None,\n    pydantic: PydanticModelDumpOptions | None = None,\n) -&gt; None\n</code></pre> <pre><code>save(path: PathLike, obj: Any, /, **kwargs) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_serde.py</code> <pre><code>def save(self, path: PathLike, obj: Any, /, **kwargs) -&gt; None:\n    path = Path(path)\n    path.write_bytes(self.encode(obj, **kwargs))\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.dec_hook","title":"dec_hook","text":"<pre><code>dec_hook(\n    typ: type,\n    obj: Any,\n    /,\n    *,\n    pydantic_options: PydanticModelValidateOptions\n    | None = None,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_decode.py</code> <pre><code>def dec_hook(\n    typ: type,\n    obj: Any,\n    /,\n    *,\n    pydantic_options: PydanticModelValidateOptions | None = None,\n) -&gt; Any:\n    if issubclass(typ, pydantic.BaseModel):\n        pydantic_options = pydantic_options or {}\n        return typ.model_validate(obj, **pydantic_options)\n    return typ(obj)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.enc_hook","title":"enc_hook","text":"<pre><code>enc_hook(obj: Any, /, **_kwargs) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_encode.py</code> <pre><code>@functools.singledispatch\ndef enc_hook(obj: Any, /, **_kwargs) -&gt; Any:\n    msg: str = f\"Objects of type {type(obj)} are not supported\"\n    raise NotImplementedError(msg)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.load","title":"load","text":"<pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    force_ext: str | None = None,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n) -&gt; Any\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    force_ext: str | None = None,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: type[T],\n) -&gt; T\n</code></pre><pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    dec_hook: DecHook | None = ...,\n    force_ext: str | None = None,\n    pydantic: PydanticModelValidateOptions | None = None,\n    strict: bool = True,\n    type: Any,\n) -&gt; Any\n</code></pre> <pre><code>load(\n    path: PathLike,\n    /,\n    *,\n    force_ext: str | None = None,\n    **kwargs,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_load.py</code> <pre><code>def load(path: PathLike, /, *, force_ext: str | None = None, **kwargs) -&gt; Any:\n    path = Path(path)\n    ext: str = force_ext or path.suffix\n    return readers[ext](path, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/serde/#liblaf.grapes.serde.save","title":"save","text":"<pre><code>save(\n    path: PathLike,\n    obj: Any,\n    /,\n    *,\n    enc_hook: EncHook | None = ...,\n    force_ext: str | None = None,\n    order: Literal[\"deterministic\", \"sorted\"] | None = None,\n    pydantic: PydanticModelDumpOptions | None = None,\n) -&gt; None\n</code></pre> <pre><code>save(\n    path: PathLike,\n    obj: Any,\n    /,\n    force_ext: str | None = None,\n    **kwargs,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/serde/_save.py</code> <pre><code>def save(path: PathLike, obj: Any, /, force_ext: str | None = None, **kwargs) -&gt; None:\n    path = Path(path)\n    ext: str = force_ext or path.suffix\n    return writers[ext](path, obj, **kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/","title":"timing","text":""},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing","title":"liblaf.grapes.timing","text":"<p>Modules:</p> <ul> <li> <code>callback</code>           \u2013            </li> <li> <code>defaults</code>           \u2013            </li> </ul> <p>Type Aliases:</p> <ul> <li> <code>ClockName</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>BaseTimer</code>           \u2013            </li> <li> <code>Timer</code>           \u2013            </li> <li> <code>Timings</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>clock</code>             \u2013              </li> <li> <code>get_timer</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>timer</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>CLOCK_REGISTRY</code>           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.CLOCK_REGISTRY","title":"CLOCK_REGISTRY  <code>module-attribute</code>","text":"<pre><code>CLOCK_REGISTRY = Registry()\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.ClockName","title":"ClockName","text":"<pre><code>ClockName = Literal[\n    \"monotonic\",\n    \"perf\",\n    \"process\",\n    \"thread\",\n    \"time\",\n    \"children-system\",\n    \"children-user\",\n    \"elapsed\",\n    \"system\",\n    \"user\",\n]\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer","title":"BaseTimer","text":"<p>               Bases: <code>Timings</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clocks</code>               (<code>Sequence[ClockName]</code>, default:                   <code>('perf',)</code> )           \u2013            </li> <li> <code>cb_start</code>               (<code>Callback | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>cb_stop</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_record at 0x7f691c654680&gt;</code> )           \u2013            </li> <li> <code>cb_finish</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_summary at 0x7f691c655300&gt;</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>timings</code>               (<code>dict[ClockName, list[float]]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>elapsed</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>pretty_record</code>             \u2013              </li> <li> <code>pretty_summary</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> <li> <code>stop</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.cb_finish","title":"cb_finish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_finish: Callback | None = log_summary\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.cb_start","title":"cb_start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_start: Callback | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.cb_stop","title":"cb_stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_stop: Callback | None = log_record\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.clocks","title":"clocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clocks: Sequence[ClockName] = field(default=DEFAULT_CLOCKS)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.default_clock","title":"default_clock  <code>property</code>","text":"<pre><code>default_clock: ClockName\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.timings","title":"timings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timings: dict[ClockName, list[float]] = field(\n    factory=lambda: defaultdict(list), init=False\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.timings[self.default_clock])\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def clear(self) -&gt; None:\n    self.timings.clear()\n    self._start_time.clear()\n    self._stop_time.clear()\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.elapsed","title":"elapsed","text":"<pre><code>elapsed(clock_name: ClockName | None = None) -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def elapsed(self, clock_name: ClockName | None = None) -&gt; float:\n    clock_name = clock_name or self.default_clock\n    stop_time: float\n    if clock_name in self._stop_time:\n        stop_time = self._stop_time[clock_name]\n    else:\n        stop_time = clock(clock_name)\n    return stop_time - self._start_time[clock_name]\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.finish","title":"finish","text":"<pre><code>finish() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def finish(self) -&gt; None:\n    __tracebackhide__ = True\n    if self.cb_finish is not None and self.cb_finish is not NOP:\n        self.cb_finish(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.log_record","title":"log_record","text":"<pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_record(\n    self,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None:\n    __tracebackhide__ = True\n    if threshold_sec is not None and self.elapsed() &lt; threshold_sec:\n        return\n    logger.log(level, self.pretty_record(index=index))\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_summary(\n    self,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None:\n    __tracebackhide__ = True\n    logger.log(level, self.pretty_summary(stats=stats))\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.pretty_record","title":"pretty_record","text":"<pre><code>pretty_record(index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_record(self, index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str:\n    name: str = self.name or \"Timer\"\n    items: list[str] = [\n        f\"{clock_name}: {pretty.pretty_duration(self.timings[clock_name][index])}\"\n        for clock_name in self.clocks\n    ]\n    items_str: str = \", \".join(items)\n    return f\"{name} &gt; {items_str}\"\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.pretty_summary","title":"pretty_summary","text":"<pre><code>pretty_summary(\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_summary(\n    self, stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS\n) -&gt; str:\n    name: str = self.name or \"Timer\"\n    header: str = f\"{name} (count: {len(self)})\"\n    if len(self) == 0:\n        return header\n    lines: list[str] = []\n    for clock_name in self.clocks:\n        stats_str: list[str] = []\n        for stat in stats:\n            stat_name: str\n            value: str\n            stat_name, value = pretty_statistic(self.timings[clock_name], stat)\n            stats_str.append(f\"{stat_name}: {value}\")\n        line: str = f\"{clock_name} &gt; {', '.join(stats_str)}\"\n        lines.append(line)\n    if len(self.clocks) == 1:\n        return f\"{header} {lines[0]}\"\n    return f\"{header}\\n\" + \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def start(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        self._start_time[clock_name] = clock(clock_name)\n    self._stop_time.clear()\n    if self.cb_start is not None and self.cb_start is not NOP:\n        self.cb_start(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.BaseTimer.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def stop(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        stop_time: float = clock(clock_name)\n        self._stop_time[clock_name] = stop_time\n        self.timings[clock_name].append(stop_time - self._start_time[clock_name])\n    if self.cb_stop is not None and self.cb_stop is not NOP:\n        self.cb_stop(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer","title":"Timer","text":"<p>               Bases: <code>BaseTimer</code>, <code>AbstractContextManager</code></p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clocks</code>               (<code>Sequence[ClockName]</code>, default:                   <code>('perf',)</code> )           \u2013            </li> <li> <code>cb_start</code>               (<code>Callback | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>cb_stop</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_record at 0x7f691c654680&gt;</code> )           \u2013            </li> <li> <code>cb_finish</code>               (<code>Callback | None</code>, default:                   <code>&lt;function log_summary at 0x7f691c655300&gt;</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>timings</code>               (<code>dict[ClockName, list[float]]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              </li> <li> <code>__call__</code>             \u2013              </li> <li> <code>__enter__</code>             \u2013              </li> <li> <code>__exit__</code>             \u2013              </li> <li> <code>__len__</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>elapsed</code>             \u2013              </li> <li> <code>finish</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>pretty_record</code>             \u2013              </li> <li> <code>pretty_summary</code>             \u2013              </li> <li> <code>start</code>             \u2013              </li> <li> <code>stop</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.cb_finish","title":"cb_finish  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_finish: Callback | None = log_summary\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.cb_start","title":"cb_start  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_start: Callback | None = None\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.cb_stop","title":"cb_stop  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cb_stop: Callback | None = log_record\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.clocks","title":"clocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clocks: Sequence[ClockName] = field(default=DEFAULT_CLOCKS)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.default_clock","title":"default_clock  <code>property</code>","text":"<pre><code>default_clock: ClockName\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.timings","title":"timings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timings: dict[ClockName, list[float]] = field(\n    factory=lambda: defaultdict(list), init=False\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    return True\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.__call__","title":"__call__","text":"<pre><code>__call__(func: C) -&gt; C\n</code></pre><pre><code>__call__(iterable: I) -&gt; I\n</code></pre> <pre><code>__call__(func_or_iterable: Callable | Iterable) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timer.py</code> <pre><code>def __call__(self, func_or_iterable: Callable | Iterable, /) -&gt; Any:\n    if callable(func_or_iterable):\n        return timed_callable(func_or_iterable, self)\n    return TimedIterable(func_or_iterable, self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timer.py</code> <pre><code>@override  # contextlib.AbstractContextManager\ndef __enter__(self) -&gt; Self:\n    __tracebackhide__ = True\n    self.start()\n    return self\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.__exit__","title":"__exit__","text":"<pre><code>__exit__(\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: TracebackType | None,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timer.py</code> <pre><code>@override  # contextlib.AbstractContextManager\ndef __exit__(\n    self,\n    exc_type: type[BaseException] | None,\n    exc_value: BaseException | None,\n    traceback: types.TracebackType | None,\n    /,\n) -&gt; None:\n    __tracebackhide__ = True\n    self.stop()\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.timings[self.default_clock])\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def clear(self) -&gt; None:\n    self.timings.clear()\n    self._start_time.clear()\n    self._stop_time.clear()\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.elapsed","title":"elapsed","text":"<pre><code>elapsed(clock_name: ClockName | None = None) -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def elapsed(self, clock_name: ClockName | None = None) -&gt; float:\n    clock_name = clock_name or self.default_clock\n    stop_time: float\n    if clock_name in self._stop_time:\n        stop_time = self._stop_time[clock_name]\n    else:\n        stop_time = clock(clock_name)\n    return stop_time - self._start_time[clock_name]\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.finish","title":"finish","text":"<pre><code>finish() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def finish(self) -&gt; None:\n    __tracebackhide__ = True\n    if self.cb_finish is not None and self.cb_finish is not NOP:\n        self.cb_finish(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.log_record","title":"log_record","text":"<pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_record(\n    self,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None:\n    __tracebackhide__ = True\n    if threshold_sec is not None and self.elapsed() &lt; threshold_sec:\n        return\n    logger.log(level, self.pretty_record(index=index))\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_summary(\n    self,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None:\n    __tracebackhide__ = True\n    logger.log(level, self.pretty_summary(stats=stats))\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.pretty_record","title":"pretty_record","text":"<pre><code>pretty_record(index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_record(self, index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str:\n    name: str = self.name or \"Timer\"\n    items: list[str] = [\n        f\"{clock_name}: {pretty.pretty_duration(self.timings[clock_name][index])}\"\n        for clock_name in self.clocks\n    ]\n    items_str: str = \", \".join(items)\n    return f\"{name} &gt; {items_str}\"\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.pretty_summary","title":"pretty_summary","text":"<pre><code>pretty_summary(\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_summary(\n    self, stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS\n) -&gt; str:\n    name: str = self.name or \"Timer\"\n    header: str = f\"{name} (count: {len(self)})\"\n    if len(self) == 0:\n        return header\n    lines: list[str] = []\n    for clock_name in self.clocks:\n        stats_str: list[str] = []\n        for stat in stats:\n            stat_name: str\n            value: str\n            stat_name, value = pretty_statistic(self.timings[clock_name], stat)\n            stats_str.append(f\"{stat_name}: {value}\")\n        line: str = f\"{clock_name} &gt; {', '.join(stats_str)}\"\n        lines.append(line)\n    if len(self.clocks) == 1:\n        return f\"{header} {lines[0]}\"\n    return f\"{header}\\n\" + \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.start","title":"start","text":"<pre><code>start() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def start(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        self._start_time[clock_name] = clock(clock_name)\n    self._stop_time.clear()\n    if self.cb_start is not None and self.cb_start is not NOP:\n        self.cb_start(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timer.stop","title":"stop","text":"<pre><code>stop() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_base.py</code> <pre><code>def stop(self) -&gt; None:\n    __tracebackhide__ = True\n    for clock_name in self.clocks:\n        stop_time: float = clock(clock_name)\n        self._stop_time[clock_name] = stop_time\n        self.timings[clock_name].append(stop_time - self._start_time[clock_name])\n    if self.cb_stop is not None and self.cb_stop is not NOP:\n        self.cb_stop(self)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings","title":"Timings","text":"<p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            </li> <li> <code>clocks</code>               (<code>Sequence[ClockName]</code>, default:                   <code>('perf',)</code> )           \u2013            </li> </ul> <p>Attributes:</p> <ul> <li> <code>timings</code>               (<code>dict[ClockName, list[float]]</code>)           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>__len__</code>             \u2013              </li> <li> <code>clear</code>             \u2013              </li> <li> <code>elapsed</code>             \u2013              </li> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> <li> <code>pretty_record</code>             \u2013              </li> <li> <code>pretty_summary</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.clocks","title":"clocks  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>clocks: Sequence[ClockName] = field(default=DEFAULT_CLOCKS)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.default_clock","title":"default_clock  <code>property</code>","text":"<pre><code>default_clock: ClockName\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name: str | None = field(default=None)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.timings","title":"timings  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>timings: dict[ClockName, list[float]] = field(\n    factory=lambda: defaultdict(list), init=False\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.__len__","title":"__len__","text":"<pre><code>__len__() -&gt; int\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def __len__(self) -&gt; int:\n    return len(self.timings[self.default_clock])\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.clear","title":"clear","text":"<pre><code>clear() -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def clear(self) -&gt; None:\n    self.timings.clear()\n    self._start_time.clear()\n    self._stop_time.clear()\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.elapsed","title":"elapsed","text":"<pre><code>elapsed(clock_name: ClockName | None = None) -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def elapsed(self, clock_name: ClockName | None = None) -&gt; float:\n    clock_name = clock_name or self.default_clock\n    stop_time: float\n    if clock_name in self._stop_time:\n        stop_time = self._stop_time[clock_name]\n    else:\n        stop_time = clock(clock_name)\n    return stop_time - self._start_time[clock_name]\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.log_record","title":"log_record","text":"<pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_record(\n    self,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; None:\n    __tracebackhide__ = True\n    if threshold_sec is not None and self.elapsed() &lt; threshold_sec:\n        return\n    logger.log(level, self.pretty_record(index=index))\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def log_summary(\n    self,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None:\n    __tracebackhide__ = True\n    logger.log(level, self.pretty_summary(stats=stats))\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.pretty_record","title":"pretty_record","text":"<pre><code>pretty_record(index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_record(self, index: int = LOG_RECORD_DEFAULT_INDEX) -&gt; str:\n    name: str = self.name or \"Timer\"\n    items: list[str] = [\n        f\"{clock_name}: {pretty.pretty_duration(self.timings[clock_name][index])}\"\n        for clock_name in self.clocks\n    ]\n    items_str: str = \", \".join(items)\n    return f\"{name} &gt; {items_str}\"\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.Timings.pretty_summary","title":"pretty_summary","text":"<pre><code>pretty_summary(\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; str\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_timings.py</code> <pre><code>def pretty_summary(\n    self, stats: Iterable[StatisticName] = LOG_SUMMARY_DEFAULT_STATISTICS\n) -&gt; str:\n    name: str = self.name or \"Timer\"\n    header: str = f\"{name} (count: {len(self)})\"\n    if len(self) == 0:\n        return header\n    lines: list[str] = []\n    for clock_name in self.clocks:\n        stats_str: list[str] = []\n        for stat in stats:\n            stat_name: str\n            value: str\n            stat_name, value = pretty_statistic(self.timings[clock_name], stat)\n            stats_str.append(f\"{stat_name}: {value}\")\n        line: str = f\"{clock_name} &gt; {', '.join(stats_str)}\"\n        lines.append(line)\n    if len(self.clocks) == 1:\n        return f\"{header} {lines[0]}\"\n    return f\"{header}\\n\" + \"\\n\".join(lines)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.clock","title":"clock","text":"<pre><code>clock(name: ClockName = 'perf') -&gt; float\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_clock.py</code> <pre><code>def clock(name: ClockName = \"perf\") -&gt; float:\n    return CLOCK_REGISTRY[name]()\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.get_timer","title":"get_timer","text":"<pre><code>get_timer(wrapper: Any) -&gt; BaseTimer\n</code></pre><pre><code>get_timer(wrapper: Any, default: T) -&gt; BaseTimer | T\n</code></pre> <pre><code>get_timer(\n    wrapper: Any, default: Any | MISSING = MISSING\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_utils.py</code> <pre><code>def get_timer(wrapper: Any, default: Any | MISSING = MISSING) -&gt; Any:\n    if default is MISSING:\n        return ft.wrapt_getattr(wrapper, \"timer\")\n    return ft.wrapt_getattr(wrapper, \"timer\", default)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.log_record","title":"log_record","text":"<pre><code>log_record(\n    timer: Timings,\n    /,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; Any\n</code></pre><pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; Callback\n</code></pre> <pre><code>log_record(\n    timer: Timings | None = None, /, **kwargs\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/callback.py</code> <pre><code>def log_record(timer: Timings | None = None, /, **kwargs) -&gt; Any:\n    __tracebackhide__ = True\n    if timer is None:\n        return functools.partial(log_record, **kwargs)\n    return timer.log_record(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    timer: Timings,\n    /,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre><pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; Callback\n</code></pre> <pre><code>log_summary(\n    timer: Timings | None = None, /, **kwargs\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/callback.py</code> <pre><code>def log_summary(timer: Timings | None = None, /, **kwargs) -&gt; Any:\n    __tracebackhide__ = True\n    if timer is None:\n        return functools.partial(log_summary, **kwargs)\n    return timer.log_summary(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/#liblaf.grapes.timing.timer","title":"timer","text":"<pre><code>timer(\n    *,\n    name: str | None = ...,\n    clocks: Sequence[ClockName] = ...,\n    cb_finish: Callback | None = ...,\n    cb_start: Callback | None = ...,\n    cb_stop: Callback | None = ...,\n) -&gt; Timer\n</code></pre><pre><code>timer(\n    callable: C,\n    /,\n    *,\n    name: str | None = ...,\n    clocks: Sequence[ClockName] = ...,\n    cb_start: Callback | None = ...,\n    cb_stop: Callback | None = ...,\n    cb_finish: Callback | None = ...,\n) -&gt; C\n</code></pre><pre><code>timer(\n    iterable: I,\n    /,\n    *,\n    name: str | None = ...,\n    clocks: Sequence[ClockName] = ...,\n    cb_start: Callback | None = ...,\n    cb_stop: Callback | None = ...,\n    cb_finish: Callback | None = ...,\n) -&gt; I\n</code></pre> <pre><code>timer(\n    func_or_iterable: Callable | Iterable | None = None,\n    /,\n    **kwargs,\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/_main.py</code> <pre><code>def timer(func_or_iterable: Callable | Iterable | None = None, /, **kwargs) -&gt; Any:\n    timer = Timer(**kwargs)\n    if func_or_iterable is None:\n        return timer\n    return timer(func_or_iterable)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/callback/","title":"callback","text":""},{"location":"reference/liblaf/grapes/timing/callback/#liblaf.grapes.timing.callback","title":"liblaf.grapes.timing.callback","text":"<p>Functions:</p> <ul> <li> <code>log_record</code>             \u2013              </li> <li> <code>log_summary</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/timing/callback/#liblaf.grapes.timing.callback.log_record","title":"log_record","text":"<pre><code>log_record(\n    timer: Timings,\n    /,\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; Any\n</code></pre><pre><code>log_record(\n    *,\n    index: int = LOG_RECORD_DEFAULT_INDEX,\n    level: int | str = LOG_RECORD_DEFAULT_LEVEL,\n    threshold_sec: float\n    | None = LOG_RECORD_DEFAULT_THRESHOLD_SEC,\n) -&gt; Callback\n</code></pre> <pre><code>log_record(\n    timer: Timings | None = None, /, **kwargs\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/callback.py</code> <pre><code>def log_record(timer: Timings | None = None, /, **kwargs) -&gt; Any:\n    __tracebackhide__ = True\n    if timer is None:\n        return functools.partial(log_record, **kwargs)\n    return timer.log_record(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/callback/#liblaf.grapes.timing.callback.log_summary","title":"log_summary","text":"<pre><code>log_summary(\n    timer: Timings,\n    /,\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; None\n</code></pre><pre><code>log_summary(\n    *,\n    level: int | str = LOG_SUMMARY_DEFAULT_LEVEL,\n    stats: Iterable[\n        StatisticName\n    ] = LOG_SUMMARY_DEFAULT_STATISTICS,\n) -&gt; Callback\n</code></pre> <pre><code>log_summary(\n    timer: Timings | None = None, /, **kwargs\n) -&gt; Any\n</code></pre> Source code in <code>src/liblaf/grapes/timing/callback.py</code> <pre><code>def log_summary(timer: Timings | None = None, /, **kwargs) -&gt; Any:\n    __tracebackhide__ = True\n    if timer is None:\n        return functools.partial(log_summary, **kwargs)\n    return timer.log_summary(**kwargs)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/defaults/","title":"defaults","text":""},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults","title":"liblaf.grapes.timing.defaults","text":"<p>Attributes:</p> <ul> <li> <code>DEFAULT_CLOCKS</code>               (<code>Sequence[ClockName]</code>)           \u2013            </li> <li> <code>LOG_RECORD_DEFAULT_INDEX</code>               (<code>int</code>)           \u2013            </li> <li> <code>LOG_RECORD_DEFAULT_LEVEL</code>               (<code>int | str</code>)           \u2013            </li> <li> <code>LOG_RECORD_DEFAULT_THRESHOLD_SEC</code>               (<code>float | None</code>)           \u2013            </li> <li> <code>LOG_SUMMARY_DEFAULT_LEVEL</code>               (<code>int | str</code>)           \u2013            </li> <li> <code>LOG_SUMMARY_DEFAULT_STATISTICS</code>               (<code>Iterable[StatisticName]</code>)           \u2013            </li> </ul>"},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults.DEFAULT_CLOCKS","title":"DEFAULT_CLOCKS  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CLOCKS: Sequence[ClockName] = ('perf',)\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults.LOG_RECORD_DEFAULT_INDEX","title":"LOG_RECORD_DEFAULT_INDEX  <code>module-attribute</code>","text":"<pre><code>LOG_RECORD_DEFAULT_INDEX: int = -1\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults.LOG_RECORD_DEFAULT_LEVEL","title":"LOG_RECORD_DEFAULT_LEVEL  <code>module-attribute</code>","text":"<pre><code>LOG_RECORD_DEFAULT_LEVEL: int | str = 'DEBUG'\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults.LOG_RECORD_DEFAULT_THRESHOLD_SEC","title":"LOG_RECORD_DEFAULT_THRESHOLD_SEC  <code>module-attribute</code>","text":"<pre><code>LOG_RECORD_DEFAULT_THRESHOLD_SEC: float | None = 0.02\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults.LOG_SUMMARY_DEFAULT_LEVEL","title":"LOG_SUMMARY_DEFAULT_LEVEL  <code>module-attribute</code>","text":"<pre><code>LOG_SUMMARY_DEFAULT_LEVEL: int | str = 'INFO'\n</code></pre>"},{"location":"reference/liblaf/grapes/timing/defaults/#liblaf.grapes.timing.defaults.LOG_SUMMARY_DEFAULT_STATISTICS","title":"LOG_SUMMARY_DEFAULT_STATISTICS  <code>module-attribute</code>","text":"<pre><code>LOG_SUMMARY_DEFAULT_STATISTICS: Iterable[StatisticName] = (\n    \"total\",\n    \"mean+stdev\",\n    \"range\",\n    \"median\",\n)\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/","title":"tqdm","text":""},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm","title":"liblaf.grapes.tqdm","text":"<p>This module provides progress tracking utilities, including a custom rate column for progress bars and a function to track the progress of iterating over sequences.</p> <p>Classes:</p> <ul> <li> <code>Progress</code>           \u2013            </li> <li> <code>RateColumn</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>parallel</code>             \u2013              </li> <li> <code>track</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.Progress","title":"Progress","text":"<pre><code>Progress(\n    *columns: str | ProgressColumn,\n    console: Console | None = None,\n    timer: Timer | Literal[False] | None = None,\n)\n</code></pre> <p>               Bases: <code>Progress</code></p> <p>Methods:</p> <ul> <li> <code>get_default_columns</code>             \u2013              </li> <li> <code>track</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>timer</code>               (<code>Timer | Literal[False]</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>def __init__(\n    self,\n    *columns: str | ProgressColumn,\n    console: Console | None = None,\n    timer: timing.Timer | Literal[False] | None = None,\n) -&gt; None:\n    if console is None:\n        console = pretty.get_console(stderr=True)\n    super().__init__(*columns, console=console)\n    if timer is None:\n        timer = timing.timer()\n    self.timer = timer\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.Progress.timer","title":"timer  <code>instance-attribute</code>","text":"<pre><code>timer: Timer | Literal[False] = timer\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.Progress.get_default_columns","title":"get_default_columns  <code>classmethod</code>","text":"<pre><code>get_default_columns() -&gt; tuple[str | ProgressColumn, ...]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>@override\n@classmethod\ndef get_default_columns(cls) -&gt; tuple[str | ProgressColumn, ...]:  # pyright: ignore[reportIncompatibleMethodOverride]\n    return (\n        SpinnerColumn(),\n        TextColumn(\"[progress.description]{task.description}\"),\n        BarColumn(),\n        TaskProgressColumn(),\n        MofNCompleteColumn(),\n        \"[\",\n        TimeElapsedColumn(),\n        \"&lt;\",\n        TimeRemainingColumn(),\n        \",\",\n        RateColumn(),\n        \"]\",\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.Progress.track","title":"track","text":"<pre><code>track(\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    task_id: TaskID | None = None,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    timer: Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>@override\ndef track[T](\n    self,\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    task_id: TaskID | None = None,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    timer: timing.Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]:\n    __tracebackhide__ = True\n    if total is None:\n        total = _it.len_or_none(sequence)\n    if timer := (timer or self.timer):\n        sequence = timer(sequence)\n        timing.get_timer(sequence).name = description\n    yield from super().track(\n        sequence,\n        total=total,\n        completed=completed,\n        task_id=task_id,\n        description=description,\n        update_period=update_period,\n    )\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.RateColumn","title":"RateColumn","text":"<pre><code>RateColumn(\n    unit: str = \"it\", table_column: Column | None = None\n)\n</code></pre> <p>               Bases: <code>ProgressColumn</code></p> <p>Methods:</p> <ul> <li> <code>render</code>             \u2013              </li> </ul> <p>Attributes:</p> <ul> <li> <code>unit</code>               (<code>str</code>)           \u2013            </li> </ul> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>def __init__(self, unit: str = \"it\", table_column: Column | None = None) -&gt; None:\n    super().__init__(table_column)\n    self.unit = unit\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.RateColumn.unit","title":"unit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>unit: str = unit\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.RateColumn.render","title":"render","text":"<pre><code>render(task: Task) -&gt; RenderableType\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_progress.py</code> <pre><code>def render(self, task: Task) -&gt; RenderableType:\n    if not task.speed:\n        return Text(f\"?{self.unit}/s\", style=\"progress.data.speed\")\n    throughput: str = pretty.pretty_throughput(task.speed, self.unit)\n    return Text(throughput, style=\"progress.data.speed\")\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.parallel","title":"parallel","text":"<pre><code>parallel(\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\"list\"] = \"list\",\n    total: int | None = None,\n) -&gt; list[T]\n</code></pre><pre><code>parallel(\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\"generator\", \"generator_unordered\"],\n    total: int | None = None,\n) -&gt; Generator[T]\n</code></pre> <pre><code>parallel(\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\n        \"list\", \"generator\", \"generator_unordered\"\n    ] = \"list\",\n    total: int | None = None,\n) -&gt; list[T] | Generator[T]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_joblib.py</code> <pre><code>def parallel[T](\n    fn: Callable[..., T],\n    *iterables: Iterable,\n    description: str = \"Working...\",\n    progress: Progress | Literal[False] | None = None,\n    return_as: Literal[\"list\", \"generator\", \"generator_unordered\"] = \"list\",\n    total: int | None = None,\n) -&gt; list[T] | Generator[T]:\n    for iterable in iterables:\n        if total is not None:\n            break\n        total = _it.len_or_none(iterable)\n\n    parallel = joblib.Parallel(return_as=return_as)\n\n    task_id: TaskID | None = None\n    if progress is None:\n        progress = Progress()\n    progress: Progress | contextlib.nullcontext\n    if progress:\n        task_id = progress.add_task(description=description, total=total)\n    else:\n        progress = contextlib.nullcontext()\n    parallel.print_progress = functools.partial(\n        print_progress, self=parallel, progress=progress, task_id=task_id\n    )\n\n    jobs = map(joblib.delayed(fn), *iterables)\n    match return_as:\n        case \"list\":\n            return as_list(parallel, jobs, progress=progress)\n        case \"generator\" | \"generator_unordered\":\n            return as_generator(parallel, jobs, progress=progress)\n</code></pre>"},{"location":"reference/liblaf/grapes/tqdm/#liblaf.grapes.tqdm.track","title":"track","text":"<pre><code>track(\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    progress: Progress | None = None,\n    timer: Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]\n</code></pre> Source code in <code>src/liblaf/grapes/tqdm/_track.py</code> <pre><code>def track[T](\n    sequence: Iterable[T],\n    total: float | None = None,\n    completed: int = 0,\n    description: str = \"Working...\",\n    update_period: float = 0.1,\n    *,\n    progress: Progress | None = None,\n    timer: timing.Timer | Literal[False] | None = None,\n) -&gt; Iterable[T]:\n    __tracebackhide__ = True\n    if timer is None:\n        timer = timing.timer(name=description)\n    if progress is None:\n        progress = Progress(timer=timer)\n    with progress:\n        yield from progress.track(\n            sequence,\n            total=total,\n            completed=completed,\n            description=description,\n            update_period=update_period,\n            timer=timer,\n        )\n</code></pre>"},{"location":"reference/liblaf/grapes/typing/","title":"typing","text":""},{"location":"reference/liblaf/grapes/typing/#liblaf.grapes.typing","title":"liblaf.grapes.typing","text":"<p>Type Aliases:</p> <ul> <li> <code>ClassInfo</code>           \u2013            </li> <li> <code>PathLike</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>array_kind</code>             \u2013              </li> <li> <code>clone_param_spec</code>             \u2013              </li> <li> <code>clone_signature</code>             \u2013              </li> </ul>"},{"location":"reference/liblaf/grapes/typing/#liblaf.grapes.typing.ClassInfo","title":"ClassInfo","text":"<pre><code>ClassInfo = type | UnionType | tuple[ClassInfo, ...]\n</code></pre>"},{"location":"reference/liblaf/grapes/typing/#liblaf.grapes.typing.PathLike","title":"PathLike","text":"<pre><code>PathLike = str | PathLike[str]\n</code></pre>"},{"location":"reference/liblaf/grapes/typing/#liblaf.grapes.typing.array_kind","title":"array_kind","text":"<pre><code>array_kind(obj: Any) -&gt; str | None\n</code></pre> Source code in <code>src/liblaf/grapes/typing/_array.py</code> <pre><code>def array_kind(obj: Any) -&gt; str | None:\n    for module, typename in [\n        (\"numpy\", \"ndarray\"),\n        (\"torch\", \"Tensor\"),\n        (\"jax\", \"Array\"),\n        (\"mlx.core\", \"array\"),\n    ]:\n        if module not in sys.modules:\n            continue\n        typ: type = getattr(sys.modules[module], typename)\n        if isinstance(obj, typ):\n            return module\n    return None\n</code></pre>"},{"location":"reference/liblaf/grapes/typing/#liblaf.grapes.typing.clone_param_spec","title":"clone_param_spec","text":"<pre><code>clone_param_spec(\n    _func: Callable[P, T],\n) -&gt; Callable[[Any], Callable[P, T]]\n</code></pre> Source code in <code>src/liblaf/grapes/typing/_utils.py</code> <pre><code>def clone_param_spec[**P, T](\n    _func: Callable[P, T], /\n) -&gt; Callable[[Any], Callable[P, T]]:\n    def wrapper(wrapped: Any, /) -&gt; Callable[P, T]:\n        return wrapped\n\n    return wrapper\n</code></pre>"},{"location":"reference/liblaf/grapes/typing/#liblaf.grapes.typing.clone_signature","title":"clone_signature","text":"<pre><code>clone_signature(_source: C) -&gt; Callable[[Any], C]\n</code></pre> Source code in <code>src/liblaf/grapes/typing/_utils.py</code> <pre><code>def clone_signature[C](_source: C, /) -&gt; Callable[[Any], C]:\n    def wrapper(obj: Any) -&gt; C:\n        return obj\n\n    return wrapper\n</code></pre>"}]}